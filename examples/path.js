/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./examples/src/path.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./dist/bundle.js":
/*!************************!*\
  !*** ./dist/bundle.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("(function(e, a) { for(var i in a) e[i] = a[i]; }(exports, /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./src/index.ts\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./src/controls/CircleController.ts\":\n/*!******************************************!*\\\n  !*** ./src/controls/CircleController.ts ***!\n  \\******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SVGGeometryController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SVGGeometryController */ \"./src/controls/SVGGeometryController.ts\");\n/* harmony import */ var _comps_interfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./comps/interfaces */ \"./src/controls/comps/interfaces.ts\");\nvar __extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\nvar CircleController =\n/** @class */\nfunction (_super) {\n  __extends(CircleController, _super);\n  /* istanbul ignore next */\n\n\n  function CircleController(element, type) {\n    if (type === void 0) {\n      type = 'circle';\n    }\n\n    return _super.call(this, element, type) || this;\n  }\n\n  CircleController.prototype.setRadius = function (radius) {\n    this.validateOrInsertFirstCoordZeroZero();\n    this.getCoordsRef()[1] = {\n      type: _comps_interfaces__WEBPACK_IMPORTED_MODULE_1__[\"CoordType\"].Scalar,\n      x: radius\n    };\n    return this;\n  };\n\n  CircleController.prototype.moveTo = function (x, y) {\n    this.getCoordsRef()[0] = {\n      x: x,\n      y: y,\n      type: _comps_interfaces__WEBPACK_IMPORTED_MODULE_1__[\"CoordType\"].Linear\n    };\n    return this;\n  };\n\n  return CircleController;\n}(_SVGGeometryController__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CircleController);\n\n/***/ }),\n\n/***/ \"./src/controls/EllipseController.ts\":\n/*!*******************************************!*\\\n  !*** ./src/controls/EllipseController.ts ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SVGGeometryController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SVGGeometryController */ \"./src/controls/SVGGeometryController.ts\");\n/* harmony import */ var _comps_interfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./comps/interfaces */ \"./src/controls/comps/interfaces.ts\");\nvar __extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\nvar EllipseController =\n/** @class */\nfunction (_super) {\n  __extends(EllipseController, _super);\n  /* istanbul ignore next */\n\n\n  function EllipseController(element, type) {\n    if (type === void 0) {\n      type = 'ellipse';\n    }\n\n    return _super.call(this, element, type) || this;\n  }\n\n  EllipseController.prototype.setRadius = function (radiusX, radiusY) {\n    this.validateOrInsertFirstCoordZeroZero();\n    this.getCoordsRef()[1] = {\n      type: _comps_interfaces__WEBPACK_IMPORTED_MODULE_1__[\"CoordType\"].Linear,\n      x: radiusX,\n      y: radiusY\n    };\n    return this;\n  };\n\n  return EllipseController;\n}(_SVGGeometryController__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (EllipseController);\n\n/***/ }),\n\n/***/ \"./src/controls/LineController.ts\":\n/*!****************************************!*\\\n  !*** ./src/controls/LineController.ts ***!\n  \\****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _SVGGeometryController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./SVGGeometryController */ \"./src/controls/SVGGeometryController.ts\");\n/* harmony import */ var _comps_interfaces__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./comps/interfaces */ \"./src/controls/comps/interfaces.ts\");\n/* harmony import */ var _comps_descriptors_SegmentsDescriptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./comps/descriptors/SegmentsDescriptor */ \"./src/controls/comps/descriptors/SegmentsDescriptor.ts\");\nvar __extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __spreadArrays = undefined && undefined.__spreadArrays || function () {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) {\n    s += arguments[i].length;\n  }\n\n  for (var r = Array(s), k = 0, i = 0; i < il; i++) {\n    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {\n      r[k] = a[j];\n    }\n  }\n\n  return r;\n};\n\n\n\n\n\nvar LineContoller =\n/** @class */\nfunction (_super) {\n  __extends(LineContoller, _super);\n  /* istanbul ignore next */\n\n\n  function LineContoller(element, type) {\n    if (type === void 0) {\n      type = 'line';\n    }\n\n    var _this = _super.call(this, element, type) || this;\n\n    _this._renderMiddlewares = [];\n    _this._segmentsDescriptor = new _comps_descriptors_SegmentsDescriptor__WEBPACK_IMPORTED_MODULE_2__[\"default\"](type);\n    return _this;\n  }\n\n  Object.defineProperty(LineContoller.prototype, \"segmentsDescriptor\", {\n    get: function get() {\n      return this._segmentsDescriptor;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Draws a stright line from latest point to target x, y\r\n   * @param x\r\n   * @param y\r\n   */\n\n  LineContoller.prototype.lineTo = function (x, y) {\n    var coord = {\n      type: _comps_interfaces__WEBPACK_IMPORTED_MODULE_1__[\"CoordType\"].Linear,\n      x: x,\n      y: y\n    };\n    this.appendCoord(coord);\n    return this;\n  };\n\n  Object.defineProperty(LineContoller.prototype, \"segmentLengths\", {\n    get: function get() {\n      return this._segmentsDescriptor.segmentLengths;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(LineContoller.prototype, \"totalLength\", {\n    get: function get() {\n      return this._segmentsDescriptor.totalLength;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Calculate geometry data like total outline length, segments length, center point, reduce shape to simple stright lines (important to paths)\r\n   */\n\n  LineContoller.prototype.calculate = function () {\n    this._segmentsDescriptor.calculate(this.getCoordsRef());\n\n    return _super.prototype.calculate.call(this);\n  };\n\n  LineContoller.prototype.getAttributesForElement = function () {\n    var reduceRenderMiddlewareCoordsUpdate = function reduceRenderMiddlewareCoordsUpdate(acc, middleware) {\n      return middleware.active ? middleware.updateCoords(acc) : acc;\n    };\n\n    var coords = this._renderMiddlewares.reduce(reduceRenderMiddlewareCoordsUpdate, __spreadArrays(this.getCoordsRef()));\n\n    return this.coordinatesParser.createElementAttrs(coords);\n  };\n\n  LineContoller.prototype.getBorderIntersection = function (p1, shapeAnchor) {\n    return this._segmentsDescriptor.getBorderIntersection(this.getCoordsRef(), p1, shapeAnchor);\n  };\n\n  LineContoller.prototype.addRenderMiddleware = function (middleware) {\n    this._renderMiddlewares.push(middleware);\n\n    middleware.setController(this);\n  };\n\n  LineContoller.prototype.removeRenderMiddleware = function (middleware) {\n    middleware.unsetController();\n\n    var i = this._renderMiddlewares.indexOf(middleware);\n\n    if (i > -1) {\n      this._renderMiddlewares.splice(i, 1);\n    }\n  };\n\n  Object.defineProperty(LineContoller.prototype, \"hasRednerMiddlewares\", {\n    get: function get() {\n      return this._renderMiddlewares.length > 0;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  return LineContoller;\n}(_SVGGeometryController__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (LineContoller);\n\n/***/ }),\n\n/***/ \"./src/controls/PathController.ts\":\n/*!****************************************!*\\\n  !*** ./src/controls/PathController.ts ***!\n  \\****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_input_validations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/input_validations */ \"./src/helpers/input_validations.ts\");\n/* harmony import */ var _PolylineController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PolylineController */ \"./src/controls/PolylineController.ts\");\n/* harmony import */ var _comps_interfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./comps/interfaces */ \"./src/controls/comps/interfaces.ts\");\nvar __extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\n\nvar PathController =\n/** @class */\nfunction (_super) {\n  __extends(PathController, _super); //private _instructions: stringOrNumber[];\n\n\n  function PathController(element, //instructions: stringOrNumber[] = [],\n  type) {\n    if (type === void 0) {\n      type = 'path';\n    }\n\n    var _this = _super.call(this, element, type) || this;\n\n    _this.cubicTo = function (ctrlX, ctrlY, ctrlX2, ctrlY2, endX, endY, mirrorEndX, mirrorEndY) {\n      // add mirror S\n      //this._instructions.push(`C${ctrlX},${ctrlY},${ctrlX2},${ctrlY2},${endX},${endY}`);\n      if (Object(_helpers_input_validations__WEBPACK_IMPORTED_MODULE_0__[\"allValuesAssigned\"])(mirrorEndX, mirrorEndY)) {\n        throw 'bezierCubic with mirror not implemented'; //this._instructions.push(`S${mirrorEndX},${mirrorEndY}`);\n      }\n\n      var coord = {\n        type: _comps_interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].BezierCubic,\n        x: endX,\n        y: endY,\n        ctrlX: ctrlX,\n        ctrlY: ctrlY,\n        ctrlX2: ctrlX2,\n        ctrlY2: ctrlY2\n      };\n\n      _this.appendCoord(coord);\n\n      return _this;\n    };\n\n    _this.quadTo = function (ctrlX, ctrlY, endX, endY, mirrorEndX, mirrorEndY) {\n      //this._instructions.push(`Q${ctrlX},${ctrlY},${endX},${endY}`);\n      var isMirror = Object(_helpers_input_validations__WEBPACK_IMPORTED_MODULE_0__[\"allValuesAssigned\"])(mirrorEndX, mirrorEndY);\n\n      if (isMirror) {\n        throw 'bezierCubic with mirror not implemented'; //this._instructions.push(`T${mirrorEndX},${mirrorEndY}`);\n      }\n\n      var coord = {\n        type: isMirror ? _comps_interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].BezierMirror : _comps_interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].BezierQuadratic,\n        x: endX,\n        y: endY,\n        ctrlX: ctrlX,\n        ctrlY: ctrlY,\n        mirrorX: mirrorEndX,\n        mirrorY: mirrorEndY\n      };\n\n      _this.appendCoord(coord);\n\n      return _this;\n    }; //this._instructions = instructions;\n\n\n    _this.element = element;\n    return _this;\n  }\n  /*\r\n  public getInstructions(): stringOrNumber[] {\r\n      return [...this._instructions];\r\n  }\r\n  */\n\n\n  PathController.prototype.getAttributesForElement = function () {\n    if (this.hasRednerMiddlewares) {\n      return _super.prototype.getAttributesForElement.call(this);\n    }\n\n    return this.coordinatesParser.createElementAttrs(this.getCoordsRef());\n  };\n\n  PathController.prototype.clear = function (updateElement) {\n    if (updateElement === void 0) {\n      updateElement = false;\n    } //this._instructions.length = 0;\n\n\n    return _super.prototype.clear.call(this, updateElement);\n  };\n\n  PathController.prototype.closePath = function () {\n    var firstCoord = this.getCoordsRef()[0];\n    this.lineTo(firstCoord.x, firstCoord.y); //this._instructions.push('z');\n    // TODO: should be part of the segments and total length in the segment desc... make sure it is working\n\n    return this;\n  };\n\n  PathController.prototype.unclose = function () {\n    // TODO: unit test unclose\n    if (this.isClosed) {\n      this.getCoordsRef().pop();\n    }\n  };\n\n  Object.defineProperty(PathController.prototype, \"isClosed\", {\n    get: function get() {\n      //return this._instructions[this._instructions.length - 1] === 'z';\n      var coords = this.getCoordsRef();\n      var lastCoord = coords[coords.length - 1];\n      return coords[0].x == lastCoord.x && coords[0].y == lastCoord.y;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  PathController.prototype.moveTo = function (x, y) {\n    //this._instructions.push(`M${x},${y}`);\n    _super.prototype.moveTo.call(this, x, y);\n\n    return this;\n  };\n\n  PathController.prototype.lineTo = function (x, y) {\n    //this._instructions.push(`L${x},${y}`);\n    this.validateOrInsertFirstCoordZeroZero();\n\n    _super.prototype.lineTo.call(this, x, y);\n\n    return this;\n  };\n\n  return PathController;\n}(_PolylineController__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PathController);\n\n/***/ }),\n\n/***/ \"./src/controls/PolygonController.ts\":\n/*!*******************************************!*\\\n  !*** ./src/controls/PolygonController.ts ***!\n  \\*******************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _PolylineController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PolylineController */ \"./src/controls/PolylineController.ts\");\nvar __extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\nvar PolygonController =\n/** @class */\nfunction (_super) {\n  __extends(PolygonController, _super);\n  /* istanbul ignore next */\n\n\n  function PolygonController(element, type) {\n    if (type === void 0) {\n      type = 'polygon';\n    }\n\n    return _super.call(this, element, type) || this;\n  }\n\n  return PolygonController;\n}(_PolylineController__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PolygonController);\n\n/***/ }),\n\n/***/ \"./src/controls/PolylineController.ts\":\n/*!********************************************!*\\\n  !*** ./src/controls/PolylineController.ts ***!\n  \\********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _LineController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineController */ \"./src/controls/LineController.ts\");\nvar __extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\nvar PolylineController =\n/** @class */\nfunction (_super) {\n  __extends(PolylineController, _super);\n  /* istanbul ignore next */\n\n\n  function PolylineController(element, type) {\n    if (type === void 0) {\n      type = 'polyline';\n    }\n\n    return _super.call(this, element, type) || this;\n  }\n\n  return PolylineController;\n}(_LineController__WEBPACK_IMPORTED_MODULE_0__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (PolylineController);\n\n/***/ }),\n\n/***/ \"./src/controls/RectController.ts\":\n/*!****************************************!*\\\n  !*** ./src/controls/RectController.ts ***!\n  \\****************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _helpers_input_validations__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../helpers/input_validations */ \"./src/helpers/input_validations.ts\");\n/* harmony import */ var _SVGGeometryController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SVGGeometryController */ \"./src/controls/SVGGeometryController.ts\");\n/* harmony import */ var _comps_interfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./comps/interfaces */ \"./src/controls/comps/interfaces.ts\");\nvar __extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\n\nvar RectController =\n/** @class */\nfunction (_super) {\n  __extends(RectController, _super);\n  /* istanbul ignore next */\n\n\n  function RectController(element, type) {\n    if (type === void 0) {\n      type = 'rect';\n    }\n\n    return _super.call(this, element, type) || this;\n  }\n\n  RectController.prototype.setDimensions = function (width, height) {\n    this.validateOrInsertFirstCoordZeroZero();\n    this.getCoordsRef()[1] = {\n      type: _comps_interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].Linear,\n      x: width,\n      y: height\n    };\n    return this;\n  };\n\n  RectController.prototype.setCornerRadius = function (x, y) {\n    this.getCoordsRef()[2] = {\n      type: _comps_interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].Linear,\n      x: x,\n      y: Object(_helpers_input_validations__WEBPACK_IMPORTED_MODULE_0__[\"valueAssigned\"])(y) ? y : x\n    };\n    return this;\n  };\n\n  return RectController;\n}(_SVGGeometryController__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (RectController);\n\n/***/ }),\n\n/***/ \"./src/controls/SVGGeometryController.ts\":\n/*!***********************************************!*\\\n  !*** ./src/controls/SVGGeometryController.ts ***!\n  \\***********************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _comps_interfaces__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./comps/interfaces */ \"./src/controls/comps/interfaces.ts\");\n/* harmony import */ var _comps_coordinates_CoordsToElemAttrs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./comps/coordinates/CoordsToElemAttrs */ \"./src/controls/comps/coordinates/CoordsToElemAttrs.ts\");\nvar __assign = undefined && undefined.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n\n      for (var p in s) {\n        if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n    }\n\n    return t;\n  };\n\n  return __assign.apply(this, arguments);\n};\n\n\n\nvar idCounter = 0;\n\nvar SVGGeometryController =\n/** @class */\nfunction () {\n  function SVGGeometryController(element, type) {\n    if (type === void 0) {\n      type = 'svg';\n    }\n\n    this._coords = [];\n    this._id = ++idCounter;\n    this._type = type;\n    this.element = element;\n    this._coordinatesParser = _comps_coordinates_CoordsToElemAttrs__WEBPACK_IMPORTED_MODULE_1__[\"CoordsToElemAttrsMap\"][type];\n  }\n\n  Object.defineProperty(SVGGeometryController.prototype, \"id\", {\n    get: function get() {\n      return this._id;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SVGGeometryController.prototype, \"type\", {\n    get: function get() {\n      return this._type;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SVGGeometryController.prototype, \"coordinatesParser\", {\n    get: function get() {\n      return this._coordinatesParser;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SVGGeometryController.prototype.getAttributesForElement = function () {\n    return this._coordinatesParser.createElementAttrs(this._coords);\n  };\n\n  SVGGeometryController.prototype.updateElement = function () {\n    var _this = this;\n\n    if (this.element) {\n      var attrs = this.getAttributesForElement();\n      Object.entries(attrs).forEach(function (_a) {\n        var key = _a[0],\n            value = _a[1];\n\n        _this.element.setAttribute(key, value);\n      });\n    }\n\n    return this;\n  };\n\n  SVGGeometryController.prototype.getCoords = function () {\n    return this._coords.map(function (coord) {\n      return __assign({}, coord);\n    });\n  };\n\n  SVGGeometryController.prototype.getCoordsRef = function () {\n    return this._coords;\n  };\n  /**\r\n   * @description must be called after manipulation (or a series of manipulation) of the shape that may effect size\r\n   */\n\n\n  SVGGeometryController.prototype.calculate = function () {\n    return this;\n  };\n\n  SVGGeometryController.prototype.appendCoord = function (coord, isMoveTo) {\n    if (isMoveTo === void 0) {\n      isMoveTo = false;\n    }\n\n    if (!isMoveTo) {\n      this.validateOrInsertFirstCoordZeroZero();\n    }\n\n    this._coords.push(coord);\n\n    this._coordinatesParser.validateCoordinates(this._coords);\n  };\n\n  SVGGeometryController.prototype.clear = function (updateElement) {\n    if (updateElement === void 0) {\n      updateElement = false;\n    }\n\n    this._coords.length = 0;\n\n    if (updateElement) {\n      this.updateElement();\n    }\n\n    return this;\n  };\n\n  SVGGeometryController.prototype.validateOrInsertFirstCoordZeroZero = function () {\n    this._coords.length === 0 && this._coords.push({\n      type: _comps_interfaces__WEBPACK_IMPORTED_MODULE_0__[\"CoordType\"].Linear,\n      x: 0,\n      y: 0\n    });\n  };\n\n  SVGGeometryController.prototype.moveTo = function (x, y) {\n    var coord = {\n      type: _comps_interfaces__WEBPACK_IMPORTED_MODULE_0__[\"CoordType\"].Linear,\n      x: x,\n      y: y,\n      move: true\n    };\n    this.appendCoord(coord, true);\n    return this;\n  };\n\n  SVGGeometryController.prototype.getElement = function () {\n    return this.element;\n  };\n\n  return SVGGeometryController;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SVGGeometryController);\n\n/***/ }),\n\n/***/ \"./src/controls/comps/coordinates/CoordsToElemAttrs.ts\":\n/*!*************************************************************!*\\\n  !*** ./src/controls/comps/coordinates/CoordsToElemAttrs.ts ***!\n  \\*************************************************************/\n/*! exports provided: CoordsToElemAttrs, CoordsToElemAttrsMap */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CoordsToElemAttrs\", function() { return CoordsToElemAttrs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CoordsToElemAttrsMap\", function() { return CoordsToElemAttrsMap; });\n/* harmony import */ var src_helpers_object_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/helpers/object_utils */ \"./src/helpers/object_utils.ts\");\n/* harmony import */ var src_helpers_input_validations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/helpers/input_validations */ \"./src/helpers/input_validations.ts\");\n/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interfaces */ \"./src/controls/comps/interfaces.ts\");\nvar __extends = undefined && undefined.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) {\n        if (b.hasOwnProperty(p)) d[p] = b[p];\n      }\n    };\n\n    return _extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    _extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\n\n\n\n\nvar CoordsToElemAttrs =\n/** @class */\nfunction () {\n  function CoordsToElemAttrs() {}\n\n  return CoordsToElemAttrs;\n}();\n\n\n\nvar StrictOrderProps =\n/** @class */\nfunction (_super) {\n  __extends(StrictOrderProps, _super);\n\n  function StrictOrderProps(orderedProps) {\n    var _this = _super.call(this) || this;\n\n    _this.orderedProps = orderedProps;\n    return _this;\n  }\n\n  StrictOrderProps.prototype.validateCoordinates = function (coords) {\n    var coordsCount = this.orderedProps.length / 2;\n\n    if (coordsCount === Math.round(coordsCount)) {\n      return coords.length === coordsCount;\n    } // validate when last coord should not have seconds value ('y' member should be undefined)\n\n\n    return coords.length === Math.ceil(coordsCount) && !Object(src_helpers_input_validations__WEBPACK_IMPORTED_MODULE_1__[\"valueAssigned\"])(coords[coords.length - 1].y);\n  };\n\n  StrictOrderProps.prototype.createElementAttrs = function (coords) {\n    var attrs = {};\n    var propIndex = 0;\n\n    for (var i = 0; i < coords.length; i++) {\n      var coord = coords[i];\n      attrs[this.orderedProps[propIndex]] = coord.x;\n\n      if (coord.type !== _interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].Scalar && propIndex + 1 < this.orderedProps.length) {\n        attrs[this.orderedProps[++propIndex]] = coord.y;\n      }\n\n      ++propIndex;\n    }\n\n    return attrs;\n  };\n\n  return StrictOrderProps;\n}(CoordsToElemAttrs);\n\nvar UnlimitedPoints =\n/** @class */\nfunction (_super) {\n  __extends(UnlimitedPoints, _super);\n\n  function UnlimitedPoints() {\n    return _super.call(this) || this;\n  }\n\n  UnlimitedPoints.prototype.validateCoordinates = function () {\n    return true;\n  };\n\n  UnlimitedPoints.prototype.createElementAttrs = function (coords) {\n    return coords.reduce(function (acc, coord) {\n      acc.points.push(coord.x);\n      acc.points.push(coord.y);\n      return acc;\n    }, {\n      points: []\n    });\n  };\n\n  return UnlimitedPoints;\n}(CoordsToElemAttrs);\n\nvar unlimitedPoints = new UnlimitedPoints(); // *********************** Path instructions ***********************\n\nvar coordToPathInstructions = Object(src_helpers_object_utils__WEBPACK_IMPORTED_MODULE_0__[\"createProxy\"])({\n  LINEAR: function LINEAR(_a) {\n    var x = _a.x,\n        y = _a.y,\n        move = _a.move;\n    return \"\" + (move ? 'M' : 'L') + x + \",\" + y;\n  },\n  BEZIER_QUADRATIC: function BEZIER_QUADRATIC(_a) {\n    var ctrlY = _a.ctrlY,\n        ctrlX = _a.ctrlX,\n        x = _a.x,\n        y = _a.y;\n    return \"Q\" + ctrlX + \",\" + ctrlY + \",\" + x + \",\" + y;\n  },\n  BEZIER_CUBIC: function BEZIER_CUBIC(_a) {\n    var ctrlY = _a.ctrlY,\n        ctrlX = _a.ctrlX,\n        ctrlX2 = _a.ctrlX2,\n        ctrlY2 = _a.ctrlY2,\n        x = _a.x,\n        y = _a.y;\n    return \"C\" + ctrlX + \",\" + ctrlY + \",\" + ctrlX2 + \",\" + ctrlY2 + \",\" + x + \",\" + y;\n  }\n}, function (coord) {\n  throw \"coordToPathInstructions can't handle coord of type \" + coord.type;\n});\n\nvar PathCoordiantesParser =\n/** @class */\nfunction (_super) {\n  __extends(PathCoordiantesParser, _super);\n\n  function PathCoordiantesParser() {\n    return _super.call(this) || this;\n  }\n\n  PathCoordiantesParser.prototype.validateCoordinates = function () {\n    return true;\n  };\n\n  PathCoordiantesParser.prototype.createElementAttrs = function (coords) {\n    var first = coords[0];\n    return {\n      d: coords.map(function (c, index) {\n        if (index === coords.length - 1 && c.type === _interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].Linear && c.x === first.x && c.y === first.y) {\n          // is close\n          return 'z';\n        }\n\n        return coordToPathInstructions[c.type](c);\n      }).join(' ')\n    };\n  };\n\n  return PathCoordiantesParser;\n}(CoordsToElemAttrs); // *********************** CoordsToElemAttrsMap ***********************\n\n\nvar CoordsToElemAttrsMap = Object(src_helpers_object_utils__WEBPACK_IMPORTED_MODULE_0__[\"createProxy\"])({\n  circle: new StrictOrderProps(['cx', 'cy', 'r']),\n  ellipse: new StrictOrderProps(['cx', 'cy', 'rx', 'ry']),\n  line: new StrictOrderProps(['x1', 'y1', 'x2', 'y2']),\n  path: new PathCoordiantesParser(),\n  polygon: unlimitedPoints,\n  polyline: unlimitedPoints,\n  rect: new StrictOrderProps(['x', 'y', 'width', 'height', 'rx', 'ry'])\n});\n\n/***/ }),\n\n/***/ \"./src/controls/comps/descriptors/SegmentsDescriptor.ts\":\n/*!**************************************************************!*\\\n  !*** ./src/controls/comps/descriptors/SegmentsDescriptor.ts ***!\n  \\**************************************************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _utils_bezier_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/bezier_utils */ \"./src/controls/comps/utils/bezier_utils.ts\");\n/* harmony import */ var src_helpers_input_validations__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/helpers/input_validations */ \"./src/helpers/input_validations.ts\");\n\n\n\nvar SegmentsDescriptor =\n/** @class */\nfunction () {\n  function SegmentsDescriptor(elementType) {\n    this._coords = [];\n    this._segmentLengths = [];\n    this._segmentAccumulatedLengths = []; // the count of simplified coords original coord has\n\n    this._segmentToSimplifiedRange = [];\n    this._totalLength = 0;\n    this._lastCoordEndsAtFirst = false;\n    this._simplfied = {};\n    this._svgElemType = elementType;\n  }\n\n  Object.defineProperty(SegmentsDescriptor.prototype, \"calculated\", {\n    get: function get() {\n      return !!this._center;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SegmentsDescriptor.prototype, \"coords\", {\n    get: function get() {\n      return this._coords;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SegmentsDescriptor.prototype, \"svgElemType\", {\n    get: function get() {\n      return this._svgElemType;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SegmentsDescriptor.prototype, \"segmentLengths\", {\n    get: function get() {\n      return this._segmentLengths;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SegmentsDescriptor.prototype, \"segmentAccumulatedLengths\", {\n    get: function get() {\n      return this._segmentAccumulatedLengths;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SegmentsDescriptor.prototype, \"segmentToSimplifiedRange\", {\n    get: function get() {\n      return this._segmentToSimplifiedRange;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SegmentsDescriptor.prototype, \"totalLength\", {\n    get: function get() {\n      return this._totalLength;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SegmentsDescriptor.prototype, \"center\", {\n    get: function get() {\n      return this._center;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SegmentsDescriptor.prototype, \"simpilfied\", {\n    get: function get() {\n      return this._simplfied;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SegmentsDescriptor.prototype, \"lastCoordEndsAtFirst\", {\n    get: function get() {\n      return this._lastCoordEndsAtFirst;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\r\n   * Should be called only be the coupled SVGElementController\r\n   * @param coords\r\n   */\n\n  SegmentsDescriptor.prototype.calculate = function (coords) {\n    this._coords = coords;\n    this._segmentLengths.length = 0; // reset data\n\n    this._totalLength = 0;\n    this._segmentAccumulatedLengths.length = 0; // reset simplfiedCoords;\n\n    this._simplfied.coords = coords.length === 0 ? [] : [coords[0].x, coords[0].y];\n    var xSum = 0;\n    var ySum = 0; // is closed shape with last coord is actially the first\n\n    this._lastCoordEndsAtFirst = coords.length > 1 && coords[0].x === coords[coords.length - 1].x && coords[0].y === coords[coords.length - 1].y;\n    var divideBy = 0;\n\n    for (var coordIndex = 0; coordIndex < coords.length; coordIndex++) {\n      var coord = coords[coordIndex];\n      var lengthCalculator = _utils_bezier_utils__WEBPACK_IMPORTED_MODULE_0__[\"coordLengthCalculators\"][coord.type.toString()];\n      var isLastCoordInClosedShape = this._lastCoordEndsAtFirst && coordIndex === coords.length - 1;\n      var points = Object(_utils_bezier_utils__WEBPACK_IMPORTED_MODULE_0__[\"getPointsOfCoord\"])(coord);\n\n      for (var i = 0; i < points.length; i += 2) {\n        if (!isLastCoordInClosedShape || i < points.length - 2) {\n          ++divideBy; // not last coord's last 2 points (x, y)\n\n          xSum += points[i];\n\n          if (Object(src_helpers_input_validations__WEBPACK_IMPORTED_MODULE_1__[\"valueAssigned\"])(points[i + 1])) {\n            ySum += points[i + 1];\n          }\n        }\n      } // if we are in first coord, it is because firstCoordIsMoveTo is true and prev coord is 0,0\n\n\n      if (coordIndex > 0) {\n        var prevCoord = coords[coordIndex - 1];\n        var previousSimplifiedCoordsLength = this._simplfied.coords.length;\n        var segmentLength = lengthCalculator(prevCoord, coord, this._simplfied.coords);\n\n        this._segmentToSimplifiedRange.push(this._simplfied.coords.length - previousSimplifiedCoordsLength);\n\n        this._segmentLengths.push(segmentLength);\n\n        this._segmentAccumulatedLengths.push((this._segmentAccumulatedLengths[this._segmentAccumulatedLengths.length - 1] || 0) + segmentLength);\n\n        this._totalLength += segmentLength;\n      }\n    } // calculate center point\n\n\n    this._center = {\n      x: xSum / divideBy,\n      y: ySum / divideBy\n    };\n  };\n\n  SegmentsDescriptor.prototype.getBorderIntersection = function (coords, p1, shapeAnchor) {\n    shapeAnchor = shapeAnchor || this._center;\n    return false;\n  };\n\n  return SegmentsDescriptor;\n}();\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (SegmentsDescriptor);\n\n/***/ }),\n\n/***/ \"./src/controls/comps/interfaces.ts\":\n/*!******************************************!*\\\n  !*** ./src/controls/comps/interfaces.ts ***!\n  \\******************************************/\n/*! exports provided: CoordType */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CoordType\", function() { return CoordType; });\nvar CoordType;\n\n(function (CoordType) {\n  CoordType[\"Scalar\"] = \"SCALAR\";\n  CoordType[\"Linear\"] = \"LINEAR\";\n  CoordType[\"BezierMirror\"] = \"BEZIER_MIRROR\";\n  CoordType[\"BezierCubic\"] = \"BEZIER_CUBIC\";\n  CoordType[\"BezierQuadratic\"] = \"BEZIER_QUADRATIC\";\n})(CoordType || (CoordType = {}));\n\n/***/ }),\n\n/***/ \"./src/controls/comps/utils/bezier_utils.ts\":\n/*!**************************************************!*\\\n  !*** ./src/controls/comps/utils/bezier_utils.ts ***!\n  \\**************************************************/\n/*! exports provided: getPointXorYOnBezier, getBezierCubicSegments, getBezierQuadraticSegments, getQuadraticBezierLength, getBezierCubicLength, pointOnCoordCalculators, coordLengthCalculators, getPointsOfCoord */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPointXorYOnBezier\", function() { return getPointXorYOnBezier; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBezierCubicSegments\", function() { return getBezierCubicSegments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBezierQuadraticSegments\", function() { return getBezierQuadraticSegments; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getQuadraticBezierLength\", function() { return getQuadraticBezierLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getBezierCubicLength\", function() { return getBezierCubicLength; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pointOnCoordCalculators\", function() { return pointOnCoordCalculators; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"coordLengthCalculators\", function() { return coordLengthCalculators; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getPointsOfCoord\", function() { return getPointsOfCoord; });\n/* harmony import */ var src_helpers_object_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! src/helpers/object_utils */ \"./src/helpers/object_utils.ts\");\n/* harmony import */ var src_helpers_shape_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! src/helpers/shape_utils */ \"./src/helpers/shape_utils.ts\");\n/* harmony import */ var _interfaces__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../interfaces */ \"./src/controls/comps/interfaces.ts\");\nvar _a;\n\n\n\n\n/**\r\n * @description return the X or Y value of an interpolated point on a bezier curve\r\n * @param t 0 to 1 value representing the position between the start and the end\r\n * @param start the X or Y value of the start point\r\n * @param startCtrl the X or Y value of the start point\r\n * @param endCtrl the X or Y value of the end point\r\n * @param end the X or Y value of the end point\r\n */\n\nfunction getPointXorYOnBezier(t, start, startCtrl, endCtrl, end) {\n  var t2 = t * t;\n  var t3 = t2 * t;\n  return start + (-start * 3 + t * (3 * start - start * t)) * t + (3 * startCtrl + t * (-6 * startCtrl + startCtrl * 3 * t)) * t + (endCtrl * 3 - endCtrl * 3 * t) * t2 + end * t3;\n}\nfunction getBezierCubicSegments(c1, c2, segmentsCount) {\n  if (segmentsCount === void 0) {\n    segmentsCount = 50;\n  }\n\n  var sectionDelta = 1 / (segmentsCount - 1);\n  var coordsAlongCurve = [];\n\n  for (var i = 0; i < segmentsCount; i++) {\n    coordsAlongCurve.push({\n      x: getPointXorYOnBezier(sectionDelta * i, c1.x, c2.ctrlX, c2.ctrlX2, c2.x),\n      y: getPointXorYOnBezier(sectionDelta * i, c1.y, c2.ctrlY, c2.ctrlY2, c2.y)\n    });\n  }\n\n  return coordsAlongCurve;\n}\nfunction getBezierQuadraticSegments(c1, c2, segmentsCount, pxTolerance) {\n  if (segmentsCount === void 0) {\n    segmentsCount = 50;\n  }\n\n  if (pxTolerance === void 0) {\n    pxTolerance = 2;\n  }\n\n  var Ax = c1.x,\n      Ay = c1.y;\n  var Bx = c2.ctrlX,\n      By = c2.ctrlY,\n      Cx = c2.x,\n      Cy = c2.y;\n  var deltaBAx = Bx - Ax;\n  var deltaCBx = Cx - Bx;\n  var deltaBAy = By - Ay;\n  var deltaCBy = Cy - By;\n  var ax, ay;\n  var lastX = -10000;\n  var lastY = -10000;\n  var pts = [{\n    x: Ax,\n    y: Ay\n  }];\n\n  for (var i = 1; i < segmentsCount - 1; i++) {\n    var t = i / segmentsCount;\n    ax = Ax + deltaBAx * t;\n    ay = Ay + deltaBAy * t;\n    var x = ax + (Bx + deltaCBx * t - ax) * t;\n    var y = ay + (By + deltaCBy * t - ay) * t;\n    var dx = x - lastX;\n    var dy = y - lastY;\n\n    if (dx * dx + dy * dy > pxTolerance) {\n      pts.push({\n        x: x,\n        y: y\n      });\n      lastX = x;\n      lastY = y;\n    }\n  }\n\n  pts.push({\n    x: Cx,\n    y: Cy\n  });\n  return pts;\n}\nfunction getQuadraticBezierLength(coord1, coord2) {\n  var x1 = coord1.x,\n      y1 = coord1.y;\n  var x2 = coord2.ctrlX,\n      y2 = coord2.ctrlY,\n      x3 = coord2.x,\n      y3 = coord2.y;\n  var a;\n  var b;\n  var c;\n  var u;\n  var v1x = x2 * 2;\n  var v1y = y2 * 2;\n  var d = x1 - v1x + x3;\n  var d1 = y1 - v1y + y3;\n  var e = v1x - 2 * x1;\n  var e1 = v1y - 2 * y1;\n  var c1 = a = 4 * (d * d + d1 * d1);\n  c1 += b = 4 * (d * e + d1 * e1);\n  c1 += c = e * e + e1 * e1;\n  c1 = 2 * Math.sqrt(c1);\n  var a1 = 2 * a * (u = Math.sqrt(a));\n  var u1 = b / u;\n  a = 4 * c * a - b * b;\n  c = 2 * Math.sqrt(c);\n  return (a1 * c1 + u * b * (c1 - c) + a * Math.log((2 * u + u1 + c1) / (u1 + c))) / (4 * a1);\n}\nfunction getBezierCubicLength(c1, c2, segmentsCount, arrayForNewCoords) {\n  if (segmentsCount === void 0) {\n    segmentsCount = 50;\n  }\n\n  var pointsAlongCurve = getBezierCubicSegments(c1, c2, segmentsCount);\n  var lengthSum = 0;\n\n  for (var i = 1; i < pointsAlongCurve.length; i++) {\n    if (arrayForNewCoords) {\n      arrayForNewCoords.push(pointsAlongCurve[i - 1].x);\n      arrayForNewCoords.push(pointsAlongCurve[i - 1].y);\n      arrayForNewCoords.push(pointsAlongCurve[i].x);\n      arrayForNewCoords.push(pointsAlongCurve[i].y);\n    }\n\n    lengthSum += Object(src_helpers_shape_utils__WEBPACK_IMPORTED_MODULE_1__[\"getDistance\"])(pointsAlongCurve[i - 1].x, pointsAlongCurve[i - 1].y, pointsAlongCurve[i].x, pointsAlongCurve[i].y);\n  }\n\n  return lengthSum;\n} // TODO: need unit tests\n\n/**\r\n * map of functions used to find a point on line (Coord) by percentage from start to end of the line (0 = start, 1 = end)\r\n */\n\nvar pointOnCoordCalculators = Object(src_helpers_object_utils__WEBPACK_IMPORTED_MODULE_0__[\"createProxy\"])({\n  LINEAR: function LINEAR(coord, percentageOfSegment, previousCoord) {\n    return {\n      x: (coord.x - previousCoord.x) * percentageOfSegment + previousCoord.x,\n      y: (coord.y - previousCoord.y) * percentageOfSegment + previousCoord.y\n    };\n  },\n  BEZIER_CUBIC: function BEZIER_CUBIC(coord, percentageOfSegment, previousCoord) {\n    var sq = coord;\n    return {\n      x: getPointXorYOnBezier(percentageOfSegment, previousCoord.x, sq.ctrlX, sq.ctrlX2, sq.x),\n      y: getPointXorYOnBezier(percentageOfSegment, previousCoord.y, sq.ctrlY, sq.ctrlY2, sq.y)\n    };\n  }\n}, function (coord) {\n  throw \"CoordType \" + coord.type + \" is not implmented in pointOnCoordCalculators\";\n});\nvar coordLengthCalculators = Object(src_helpers_object_utils__WEBPACK_IMPORTED_MODULE_0__[\"createProxy\"])({\n  LINEAR: function LINEAR(c1, c2, newCoords) {\n    if (newCoords) {\n      newCoords.push(c2.x);\n      newCoords.push(c2.y);\n    }\n\n    return Object(src_helpers_shape_utils__WEBPACK_IMPORTED_MODULE_1__[\"getDistance\"])(c1.x, c1.y || 0, c2.x, c2.y || 0);\n  },\n  BEZIER_CUBIC: function BEZIER_CUBIC(c1, c2, newCoords) {\n    return getBezierCubicLength(c1, c2, 50, newCoords);\n  }\n}, function (prevCoord, coord) {\n  throw \"CoordType \" + coord.type + \" is not implmented in coordLengthCalculators\";\n});\nvar arr1 = new Array(1);\nvar arr2 = new Array(2);\nvar arr4 = new Array(4);\nvar arr6 = new Array(6);\nvar getPointsCoordHandlerMap = (_a = {}, _a[_interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].Scalar] = function (coord) {\n  arr1[0] = coord.x;\n  return arr1;\n}, _a[_interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].Linear] = function (coord) {\n  arr2[0] = coord.x;\n  arr2[1] = coord.y;\n  return arr2;\n}, _a[_interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].BezierQuadratic] = function (coord) {\n  arr4[0] = coord.x;\n  arr4[1] = coord.y;\n  arr4[2] = coord.ctrlX;\n  arr4[3] = coord.ctrlY;\n  return arr4;\n}, _a[_interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].BezierCubic] = function (coord) {\n  arr6[0] = coord.x;\n  arr6[1] = coord.y;\n  arr6[2] = coord.ctrlX;\n  arr6[3] = coord.ctrlY;\n  arr6[4] = coord.ctrlX2;\n  arr6[5] = coord.ctrlY2;\n  return arr6;\n}, _a[_interfaces__WEBPACK_IMPORTED_MODULE_2__[\"CoordType\"].BezierMirror] = function () {\n  throw 'break BezierMirror to coords not implemented';\n}, _a);\nvar getPointsOfCoord = function getPointsOfCoord(coord) {\n  return getPointsCoordHandlerMap[coord.type](coord);\n};\n\n/***/ }),\n\n/***/ \"./src/controls/index.ts\":\n/*!*******************************!*\\\n  !*** ./src/controls/index.ts ***!\n  \\*******************************/\n/*! exports provided: LineController, PathController, PolygonController, PolylineController, CircleController, EllipseController, RectController */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _LineController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./LineController */ \"./src/controls/LineController.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LineController\", function() { return _LineController__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _PathController__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./PathController */ \"./src/controls/PathController.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PathController\", function() { return _PathController__WEBPACK_IMPORTED_MODULE_1__[\"default\"]; });\n\n/* harmony import */ var _PolygonController__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./PolygonController */ \"./src/controls/PolygonController.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PolygonController\", function() { return _PolygonController__WEBPACK_IMPORTED_MODULE_2__[\"default\"]; });\n\n/* harmony import */ var _PolylineController__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./PolylineController */ \"./src/controls/PolylineController.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PolylineController\", function() { return _PolylineController__WEBPACK_IMPORTED_MODULE_3__[\"default\"]; });\n\n/* harmony import */ var _CircleController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./CircleController */ \"./src/controls/CircleController.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CircleController\", function() { return _CircleController__WEBPACK_IMPORTED_MODULE_4__[\"default\"]; });\n\n/* harmony import */ var _EllipseController__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./EllipseController */ \"./src/controls/EllipseController.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EllipseController\", function() { return _EllipseController__WEBPACK_IMPORTED_MODULE_5__[\"default\"]; });\n\n/* harmony import */ var _RectController__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./RectController */ \"./src/controls/RectController.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RectController\", function() { return _RectController__WEBPACK_IMPORTED_MODULE_6__[\"default\"]; });\n\n\n\n\n\n\n\n\n\n\n/***/ }),\n\n/***/ \"./src/createSVGElement.ts\":\n/*!*********************************!*\\\n  !*** ./src/createSVGElement.ts ***!\n  \\*********************************/\n/*! exports provided: default */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return createSVGElement; });\n/* harmony import */ var _helpers_object_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/object_utils */ \"./src/helpers/object_utils.ts\");\n/* harmony import */ var _helpers_function_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/function_utils */ \"./src/helpers/function_utils.ts\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\n\n/* istanbul ignore next */\n\nvar getParentFunctionByType = Object(_helpers_object_utils__WEBPACK_IMPORTED_MODULE_0__[\"createProxy\"])({\n  string: function string(selector) {\n    return document.querySelector(selector);\n  }\n}, _helpers_function_utils__WEBPACK_IMPORTED_MODULE_1__[\"identityFn\"]);\nfunction createSVGElement(type, svgParent, id, classNames) {\n  var elem = document.createElementNS('http://www.w3.org/2000/svg', type);\n  id && (elem.id = id);\n  classNames && elem.setAttribute('class', classNames);\n  svgParent && getParentFunctionByType[_typeof(svgParent)](svgParent).appendChild(elem);\n  return elem;\n}\n\n/***/ }),\n\n/***/ \"./src/helpers/function_utils.ts\":\n/*!***************************************!*\\\n  !*** ./src/helpers/function_utils.ts ***!\n  \\***************************************/\n/*! exports provided: identityFn, emptyFn */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"identityFn\", function() { return identityFn; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"emptyFn\", function() { return emptyFn; });\nvar identityFn = function identityFn(x) {\n  return x;\n};\n\nvar emptyFn = function emptyFn() {};\n\n\n\n/***/ }),\n\n/***/ \"./src/helpers/input_validations.ts\":\n/*!******************************************!*\\\n  !*** ./src/helpers/input_validations.ts ***!\n  \\******************************************/\n/*! exports provided: valueAssigned, allValuesAssigned, allArrayMembersAssigned, isEmpty */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"valueAssigned\", function() { return valueAssigned; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"allValuesAssigned\", function() { return allValuesAssigned; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"allArrayMembersAssigned\", function() { return allArrayMembersAssigned; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEmpty\", function() { return isEmpty; });\n/* harmony import */ var _object_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./object_utils */ \"./src/helpers/object_utils.ts\");\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n\nvar assignedTests = Object(_object_utils__WEBPACK_IMPORTED_MODULE_0__[\"createProxy\"])({\n  object: function object(val) {\n    return val !== null;\n  },\n  number: function number(val) {\n    return !isNaN(val);\n  },\n  undefined: function undefined() {\n    return false;\n  }\n}, function () {\n  return true;\n});\nvar isEmptyTests = Object(_object_utils__WEBPACK_IMPORTED_MODULE_0__[\"createProxy\"])({\n  string: function string(val) {\n    return val.length === 0;\n  },\n  number: function number(val) {\n    return isNaN(val);\n  },\n  undefined: function undefined() {\n    return true;\n  },\n  symbol: function symbol() {\n    return false;\n  },\n  object: function object(val) {\n    if (val === null) {\n      return true;\n    } else if (Array.isArray(val)) {\n      return val.length === 0;\n    }\n\n    return Object.keys(val).length === 0;\n  }\n},\n/* istanbul ignore next */\nfunction (val) {\n  throw \"can't check if \" + val + \" is empty. validation test for type \" + _typeof(val) + \" is not defined (?!)\";\n});\n/**\r\n * @description test to see the value *IS NOT* null / undefined / NaN\r\n * @param val\r\n * @returns boolean\r\n */\n\nvar valueAssigned = function valueAssigned(val) {\n  return assignedTests[_typeof(val)](val);\n};\n/**\r\n * @descipriotn check none of the provided arguments is null / undefined / NaN. uses valueAssigned. for validating members of array, use allArrayMembersAssigned\r\n * @see {@link valueAssigned}\r\n * @see {@link allArrayMembersAssigned}\r\n * @param args\r\n * @returns boolean\r\n */\n\n\nvar allValuesAssigned = function allValuesAssigned() {\n  var args = [];\n\n  for (var _i = 0; _i < arguments.length; _i++) {\n    args[_i] = arguments[_i];\n  }\n\n  return args.every(valueAssigned);\n};\n/**\r\n * @description check all members of the provided array are assigned. uses valueAssigned.\r\n * @param array\r\n * @see {@link valueAssigned}\r\n * @returns boolean\r\n */\n\n\nvar allArrayMembersAssigned = function allArrayMembersAssigned(array) {\n  return array.every(valueAssigned);\n};\n/**\r\n * @description checks in the value is empty ({}, [], NaN, null, undefined)\r\n * @param val\r\n * @returns boolean\r\n */\n\n\nvar isEmpty = function isEmpty(val) {\n  return isEmptyTests[_typeof(val)](val);\n};\n\n\n\n/***/ }),\n\n/***/ \"./src/helpers/object_utils.ts\":\n/*!*************************************!*\\\n  !*** ./src/helpers/object_utils.ts ***!\n  \\*************************************/\n/*! exports provided: emptyObj, createProxy */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"emptyObj\", function() { return emptyObj; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createProxy\", function() { return createProxy; });\nfunction createProxy(target, def) {\n  var handler = {\n    get: function get(target, prop) {\n      return target[prop] || def;\n    }\n  };\n  return new Proxy(target, handler);\n}\n\nvar emptyObj = Object.freeze({});\n\n\n/***/ }),\n\n/***/ \"./src/helpers/shape_utils.ts\":\n/*!************************************!*\\\n  !*** ./src/helpers/shape_utils.ts ***!\n  \\************************************/\n/*! exports provided: bezierControlPointOffsetForQuarterCircle, getDistance, getDistanceByPower2, getSquarePerimeter, getCircleCircumference, lineIntersection */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"bezierControlPointOffsetForQuarterCircle\", function() { return bezierControlPointOffsetForQuarterCircle; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDistance\", function() { return getDistance; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getDistanceByPower2\", function() { return getDistanceByPower2; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getSquarePerimeter\", function() { return getSquarePerimeter; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCircleCircumference\", function() { return getCircleCircumference; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"lineIntersection\", function() { return lineIntersection; });\n// (4/3)*Math.tan(Math.PI / 8)\nvar bezierControlPointOffsetForQuarterCircle = 0.5522847498307933;\nfunction getDistance(x1, y1, x2, y2) {\n  return Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n} // TODO: add unit test\n\nfunction getDistanceByPower2(x1, y1, x2, y2) {\n  return (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);\n}\nfunction getSquarePerimeter(width, height) {\n  return (width + height) * 2;\n}\nfunction getCircleCircumference(radius) {\n  return 2 * Math.PI * radius;\n}\nfunction lineIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\n  var ua,\n      ub,\n      denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);\n\n  if (denom == 0) {\n    return null;\n  }\n\n  ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;\n  ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;\n  return {\n    x: x1 + ua * (x2 - x1),\n    y: y1 + ua * (y2 - y1),\n    seg1: ua >= 0 && ua <= 1,\n    seg2: ub >= 0 && ub <= 1\n  };\n}\n\n/***/ }),\n\n/***/ \"./src/index.ts\":\n/*!**********************!*\\\n  !*** ./src/index.ts ***!\n  \\**********************/\n/*! exports provided: createSVGElement, LineController, PathController, PolygonController, PolylineController, CircleController, EllipseController, RectController */\n/***/ (function(module, __webpack_exports__, __webpack_require__) {\n\n\"use strict\";\n__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _createSVGElement__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./createSVGElement */ \"./src/createSVGElement.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"createSVGElement\", function() { return _createSVGElement__WEBPACK_IMPORTED_MODULE_0__[\"default\"]; });\n\n/* harmony import */ var _controls_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./controls/index */ \"./src/controls/index.ts\");\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"LineController\", function() { return _controls_index__WEBPACK_IMPORTED_MODULE_1__[\"LineController\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PathController\", function() { return _controls_index__WEBPACK_IMPORTED_MODULE_1__[\"PathController\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PolygonController\", function() { return _controls_index__WEBPACK_IMPORTED_MODULE_1__[\"PolygonController\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"PolylineController\", function() { return _controls_index__WEBPACK_IMPORTED_MODULE_1__[\"PolylineController\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"CircleController\", function() { return _controls_index__WEBPACK_IMPORTED_MODULE_1__[\"CircleController\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"EllipseController\", function() { return _controls_index__WEBPACK_IMPORTED_MODULE_1__[\"EllipseController\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RectController\", function() { return _controls_index__WEBPACK_IMPORTED_MODULE_1__[\"RectController\"]; });\n\n\n\n\n\n/***/ })\n\n/******/ })));\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2xzL0NpcmNsZUNvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2xzL0VsbGlwc2VDb250cm9sbGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb250cm9scy9MaW5lQ29udHJvbGxlci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29udHJvbHMvUGF0aENvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2xzL1BvbHlnb25Db250cm9sbGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb250cm9scy9Qb2x5bGluZUNvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2xzL1JlY3RDb250cm9sbGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9jb250cm9scy9TVkdHZW9tZXRyeUNvbnRyb2xsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2xzL2NvbXBzL2Nvb3JkaW5hdGVzL0Nvb3Jkc1RvRWxlbUF0dHJzLnRzIiwid2VicGFjazovLy8uL3NyYy9jb250cm9scy9jb21wcy9kZXNjcmlwdG9ycy9TZWdtZW50c0Rlc2NyaXB0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2xzL2NvbXBzL2ludGVyZmFjZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NvbnRyb2xzL2NvbXBzL3V0aWxzL2Jlemllcl91dGlscy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvY29udHJvbHMvaW5kZXgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2NyZWF0ZVNWR0VsZW1lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvZnVuY3Rpb25fdXRpbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvaW5wdXRfdmFsaWRhdGlvbnMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hlbHBlcnMvb2JqZWN0X3V0aWxzLnRzIiwid2VicGFjazovLy8uL3NyYy9oZWxwZXJzL3NoYXBlX3V0aWxzLnRzIiwid2VicGFjazovLy8uL3NyYy9pbmRleC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBOEM7QUFDN0M7OztBQUNBLDRCQUFZLE9BQVosRUFBa0MsSUFBbEMsRUFBa0U7QUFBaEM7QUFBQTtBQUFnQzs7V0FDakUsa0JBQU0sT0FBTixFQUFlLElBQWYsS0FBb0IsSTtBQUNwQjs7QUFFTSx5Q0FBUCxVQUFpQixNQUFqQixFQUErQjtBQUM5QixTQUFLLGtDQUFMO0FBQ0EsU0FBSyxZQUFMLEdBQW9CLENBQXBCLElBQXlCO0FBQUUsVUFBSSxFQUFFLDJEQUFTLENBQUMsTUFBbEI7QUFBMEIsT0FBQyxFQUFFO0FBQTdCLEtBQXpCO0FBQ0EsV0FBTyxJQUFQO0FBQ0EsR0FKTTs7QUFNQSxzQ0FBUCxVQUFjLENBQWQsRUFBeUIsQ0FBekIsRUFBa0M7QUFDakMsU0FBSyxZQUFMLEdBQW9CLENBQXBCLElBQXlCO0FBQUUsT0FBQyxHQUFIO0FBQUssT0FBQyxHQUFOO0FBQVEsVUFBSSxFQUFFLDJEQUFTLENBQUM7QUFBeEIsS0FBekI7QUFDQSxXQUFPLElBQVA7QUFDQSxHQUhNOztBQUlSO0FBQUMsQ0FoQkQsQ0FBOEMsOERBQTlDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBK0M7QUFDOUM7OztBQUNBLDZCQUFZLE9BQVosRUFBa0MsSUFBbEMsRUFBbUU7QUFBakM7QUFBQTtBQUFpQzs7V0FDbEUsa0JBQU0sT0FBTixFQUFlLElBQWYsS0FBb0IsSTtBQUNwQjs7QUFFTSwwQ0FBUCxVQUFpQixPQUFqQixFQUFrQyxPQUFsQyxFQUFpRDtBQUNoRCxTQUFLLGtDQUFMO0FBQ0EsU0FBSyxZQUFMLEdBQW9CLENBQXBCLElBQXlCO0FBQUUsVUFBSSxFQUFFLDJEQUFTLENBQUMsTUFBbEI7QUFBMEIsT0FBQyxFQUFFLE9BQTdCO0FBQXNDLE9BQUMsRUFBRTtBQUF6QyxLQUF6QjtBQUNBLFdBQU8sSUFBUDtBQUNBLEdBSk07O0FBS1I7QUFBQyxDQVhELENBQStDLDhEQUEvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTs7QUFHQTtBQUFBO0FBQUE7QUFDUztBQUtSOzs7QUFDQSx5QkFBWSxPQUFaLEVBQWtDLElBQWxDLEVBQWdFO0FBQTlCO0FBQUE7QUFBOEI7O0FBQWhFLGdCQUNDLGtCQUFNLE9BQU4sRUFBZSxJQUFmLEtBQW9CLElBRHJCOztBQUhRLCtCQUF5QyxFQUF6QztBQUtQLFNBQUksQ0FBQyxtQkFBTCxHQUEyQixJQUFJLDZFQUFKLENBQXVCLElBQXZCLENBQTNCOztBQUNBOztBQUNELHdCQUFXLHVCQUFYLEVBQVcsb0JBQVgsRUFBNkI7U0FBN0I7QUFDQyxhQUFPLEtBQUssbUJBQVo7QUFDQSxLQUY0QjtvQkFBQTs7QUFBQSxHQUE3QjtBQUlBOzs7Ozs7QUFLTyxtQ0FBUCxVQUFjLENBQWQsRUFBeUIsQ0FBekIsRUFBa0M7QUFDakMsUUFBTSxLQUFLLEdBQVU7QUFBRSxVQUFJLEVBQUUsMkRBQVMsQ0FBQyxNQUFsQjtBQUEwQixPQUFDLEdBQTNCO0FBQTZCLE9BQUM7QUFBOUIsS0FBckI7QUFDQSxTQUFLLFdBQUwsQ0FBaUIsS0FBakI7QUFDQSxXQUFPLElBQVA7QUFDQSxHQUpNOztBQU1QLHdCQUFXLHVCQUFYLEVBQVcsZ0JBQVgsRUFBeUI7U0FBekI7QUFDQyxhQUFPLEtBQUssbUJBQUwsQ0FBeUIsY0FBaEM7QUFDQSxLQUZ3QjtvQkFBQTs7QUFBQSxHQUF6QjtBQUlBLHdCQUFXLHVCQUFYLEVBQVcsYUFBWCxFQUFzQjtTQUF0QjtBQUNDLGFBQU8sS0FBSyxtQkFBTCxDQUF5QixXQUFoQztBQUNBLEtBRnFCO29CQUFBOztBQUFBLEdBQXRCO0FBSUE7Ozs7QUFHTyxzQ0FBUDtBQUNDLFNBQUssbUJBQUwsQ0FBeUIsU0FBekIsQ0FBbUMsS0FBSyxZQUFMLEVBQW5DOztBQUNBLFdBQU8saUJBQU0sU0FBTixDQUFlLElBQWYsQ0FBZSxJQUFmLENBQVA7QUFDQSxHQUhNOztBQUtBLG9EQUFQO0FBQ0MsUUFBTSxrQ0FBa0MsR0FBRyxTQUFyQyxrQ0FBcUMsQ0FDMUMsR0FEMEMsRUFFMUMsVUFGMEMsRUFFZDtBQUU1QixhQUFPLFVBQVUsQ0FBQyxNQUFYLEdBQW9CLFVBQVUsQ0FBQyxZQUFYLENBQXdCLEdBQXhCLENBQXBCLEdBQW1ELEdBQTFEO0FBQ0EsS0FMRDs7QUFPQSxRQUFNLE1BQU0sR0FBWSxLQUFLLGtCQUFMLENBQXdCLE1BQXhCLENBQStCLGtDQUEvQixFQUFpRSxlQUNyRixLQUFLLFlBQUwsRUFEcUYsQ0FBakUsQ0FBeEI7O0FBR0EsV0FBTyxLQUFLLGlCQUFMLENBQXVCLGtCQUF2QixDQUEwQyxNQUExQyxDQUFQO0FBQ0EsR0FaTTs7QUFjQSxrREFBUCxVQUE2QixFQUE3QixFQUF3QyxXQUF4QyxFQUEyRDtBQUMxRCxXQUFPLEtBQUssbUJBQUwsQ0FBeUIscUJBQXpCLENBQStDLEtBQUssWUFBTCxFQUEvQyxFQUFvRSxFQUFwRSxFQUF3RSxXQUF4RSxDQUFQO0FBQ0EsR0FGTTs7QUFJQSxnREFBUCxVQUEyQixVQUEzQixFQUF1RDtBQUN0RCxTQUFLLGtCQUFMLENBQXdCLElBQXhCLENBQTZCLFVBQTdCOztBQUNBLGNBQVUsQ0FBQyxhQUFYLENBQXlCLElBQXpCO0FBQ0EsR0FITTs7QUFLQSxtREFBUCxVQUE4QixVQUE5QixFQUEwRDtBQUN6RCxjQUFVLENBQUMsZUFBWDs7QUFDQSxRQUFNLENBQUMsR0FBRyxLQUFLLGtCQUFMLENBQXdCLE9BQXhCLENBQWdDLFVBQWhDLENBQVY7O0FBQ0EsUUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFULEVBQVk7QUFDWCxXQUFLLGtCQUFMLENBQXdCLE1BQXhCLENBQStCLENBQS9CLEVBQWtDLENBQWxDO0FBQ0E7QUFDRCxHQU5NOztBQVFQLHdCQUFXLHVCQUFYLEVBQVcsc0JBQVgsRUFBK0I7U0FBL0I7QUFDQyxhQUFPLEtBQUssa0JBQUwsQ0FBd0IsTUFBeEIsR0FBaUMsQ0FBeEM7QUFDQSxLQUY4QjtvQkFBQTs7QUFBQSxHQUEvQjtBQUdEO0FBQUMsQ0E1RUQsQ0FDUyw4REFEVDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNMQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQTRDLG9DQUE1QyxDQUNDOzs7QUFFQSwwQkFDQyxPQURELEVBRUM7QUFDQSxNQUhELEVBRytCO0FBQTlCO0FBQUE7QUFBOEI7O0FBSC9CLGdCQUtDLGtCQUFNLE9BQU4sRUFBZSxJQUFmLEtBQW9CLElBTHJCOztBQTZETyxvQkFBVSxVQUNoQixLQURnQixFQUVoQixLQUZnQixFQUdoQixNQUhnQixFQUloQixNQUpnQixFQUtoQixJQUxnQixFQU1oQixJQU5nQixFQU9oQixVQVBnQixFQVFoQixVQVJnQixFQVFHO0FBRW5CO0FBRUE7QUFFQSxVQUFJLG9GQUFpQixDQUFDLFVBQUQsRUFBYSxVQUFiLENBQXJCLEVBQStDO0FBQzlDLGNBQU0seUNBQU4sQ0FEOEMsQ0FFOUM7QUFDQTs7QUFFRCxVQUFNLEtBQUssR0FBcUI7QUFDL0IsWUFBSSxFQUFFLDJEQUFTLENBQUMsV0FEZTtBQUUvQixTQUFDLEVBQUUsSUFGNEI7QUFHL0IsU0FBQyxFQUFFLElBSDRCO0FBSS9CLGFBQUssT0FKMEI7QUFLL0IsYUFBSyxPQUwwQjtBQU0vQixjQUFNLFFBTnlCO0FBTy9CLGNBQU07QUFQeUIsT0FBaEM7O0FBU0EsV0FBSSxDQUFDLFdBQUwsQ0FBaUIsS0FBakI7O0FBQ0EsYUFBTyxLQUFQO0FBQ0EsS0E5Qk07O0FBZ0NBLG1CQUFTLFVBQ2YsS0FEZSxFQUVmLEtBRmUsRUFHZixJQUhlLEVBSWYsSUFKZSxFQUtmLFVBTGUsRUFNZixVQU5lLEVBTUk7QUFFbkI7QUFDQSxVQUFNLFFBQVEsR0FBRyxvRkFBaUIsQ0FBQyxVQUFELEVBQWEsVUFBYixDQUFsQzs7QUFDQSxVQUFJLFFBQUosRUFBYztBQUNiLGNBQU0seUNBQU4sQ0FEYSxDQUViO0FBQ0E7O0FBQ0QsVUFBTSxLQUFLLEdBQXlCO0FBQ25DLFlBQUksRUFBRSxRQUFRLEdBQUcsMkRBQVMsQ0FBQyxZQUFiLEdBQTRCLDJEQUFTLENBQUMsZUFEakI7QUFFbkMsU0FBQyxFQUFFLElBRmdDO0FBR25DLFNBQUMsRUFBRSxJQUhnQztBQUluQyxhQUFLLE9BSjhCO0FBS25DLGFBQUssT0FMOEI7QUFNbkMsZUFBTyxFQUFFLFVBTjBCO0FBT25DLGVBQU8sRUFBRTtBQVAwQixPQUFwQzs7QUFTQSxXQUFJLENBQUMsV0FBTCxDQUFpQixLQUFqQjs7QUFFQSxhQUFPLEtBQVA7QUFDQSxLQTFCTSxDQTFGd0IsQ0FHOUI7OztBQUNBLFNBQUksQ0FBQyxPQUFMLEdBQWUsT0FBZjs7QUFDQTtBQUNEOzs7Ozs7O0FBS08scURBQVA7QUFDQyxRQUFJLEtBQUssb0JBQVQsRUFBK0I7QUFDOUIsYUFBTyxpQkFBTSx1QkFBTixDQUE2QixJQUE3QixDQUE2QixJQUE3QixDQUFQO0FBQ0E7O0FBQ0QsV0FBTyxLQUFLLGlCQUFMLENBQXVCLGtCQUF2QixDQUEwQyxLQUFLLFlBQUwsRUFBMUMsQ0FBUDtBQUNBLEdBTE07O0FBT0EsbUNBQVAsVUFBYSxhQUFiLEVBQWtDO0FBQXJCO0FBQUE7QUFBcUIsTUFDakM7OztBQUNBLFdBQU8saUJBQU0sS0FBTixDQUFXLElBQVgsQ0FBVyxJQUFYLEVBQVksYUFBWixDQUFQO0FBQ0EsR0FITTs7QUFLQSx1Q0FBUDtBQUNDLFFBQU0sVUFBVSxHQUFHLEtBQUssWUFBTCxHQUFvQixDQUFwQixDQUFuQjtBQUNBLFNBQUssTUFBTCxDQUFZLFVBQVUsQ0FBQyxDQUF2QixFQUEwQixVQUFVLENBQUMsQ0FBckMsRUFGRCxDQUdDO0FBQ0E7O0FBQ0EsV0FBTyxJQUFQO0FBQ0EsR0FOTTs7QUFRQSxxQ0FBUDtBQUNDO0FBQ0EsUUFBSSxLQUFLLFFBQVQsRUFBbUI7QUFDbEIsV0FBSyxZQUFMLEdBQW9CLEdBQXBCO0FBQ0E7QUFDRCxHQUxNOztBQU9QLHdCQUFXLHdCQUFYLEVBQVcsVUFBWCxFQUFtQjtTQUFuQjtBQUNDO0FBQ0EsVUFBTSxNQUFNLEdBQUcsS0FBSyxZQUFMLEVBQWY7QUFDQSxVQUFNLFNBQVMsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsQ0FBakIsQ0FBeEI7QUFDQSxhQUFPLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLElBQWUsU0FBUyxDQUFDLENBQXpCLElBQThCLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFWLElBQWUsU0FBUyxDQUFDLENBQTlEO0FBQ0EsS0FMa0I7b0JBQUE7O0FBQUEsR0FBbkI7O0FBT08sb0NBQVAsVUFBYyxDQUFkLEVBQXlCLENBQXpCLEVBQWtDO0FBQ2pDO0FBQ0EscUJBQU0sTUFBTixDQUFZLElBQVosQ0FBWSxJQUFaLEVBQWEsQ0FBYixFQUFnQixDQUFoQjs7QUFDQSxXQUFPLElBQVA7QUFDQSxHQUpNOztBQU1BLG9DQUFQLFVBQWMsQ0FBZCxFQUF5QixDQUF6QixFQUFrQztBQUNqQztBQUNBLFNBQUssa0NBQUw7O0FBQ0EscUJBQU0sTUFBTixDQUFZLElBQVosQ0FBWSxJQUFaLEVBQWEsQ0FBYixFQUFnQixDQUFoQjs7QUFDQSxXQUFPLElBQVA7QUFDQSxHQUxNOztBQWtFUjtBQUFDLENBM0hELENBQTRDLDJEQUE1Qzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDSkE7O0FBRUE7QUFBQTtBQUFBO0FBQStDO0FBQzlDOzs7QUFDQSw2QkFBWSxPQUFaLEVBQWtDLElBQWxDLEVBQW1FO0FBQWpDO0FBQUE7QUFBaUM7O1dBQ2xFLGtCQUFNLE9BQU4sRUFBZSxJQUFmLEtBQW9CLEk7QUFDcEI7O0FBQ0Y7QUFBQyxDQUxELENBQStDLDJEQUEvQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDRkE7O0FBRUE7QUFBQTtBQUFBO0FBQWdEO0FBQy9DOzs7QUFDQSw4QkFBWSxPQUFaLEVBQWtDLElBQWxDLEVBQW9FO0FBQWxDO0FBQUE7QUFBa0M7O1dBQ25FLGtCQUFNLE9BQU4sRUFBZSxJQUFmLEtBQW9CLEk7QUFDcEI7O0FBQ0Y7QUFBQyxDQUxELENBQWdELHVEQUFoRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNGQTtBQUNBO0FBQ0E7O0FBRUE7QUFBQTtBQUFBO0FBQTRDO0FBQzNDOzs7QUFDQSwwQkFBWSxPQUFaLEVBQWtDLElBQWxDLEVBQWdFO0FBQTlCO0FBQUE7QUFBOEI7O1dBQy9ELGtCQUFNLE9BQU4sRUFBZSxJQUFmLEtBQW9CLEk7QUFDcEI7O0FBRU0sMkNBQVAsVUFBcUIsS0FBckIsRUFBb0MsTUFBcEMsRUFBa0Q7QUFDakQsU0FBSyxrQ0FBTDtBQUNBLFNBQUssWUFBTCxHQUFvQixDQUFwQixJQUF5QjtBQUFFLFVBQUksRUFBRSwyREFBUyxDQUFDLE1BQWxCO0FBQTBCLE9BQUMsRUFBRSxLQUE3QjtBQUFvQyxPQUFDLEVBQUU7QUFBdkMsS0FBekI7QUFDQSxXQUFPLElBQVA7QUFDQSxHQUpNOztBQU1BLDZDQUFQLFVBQXVCLENBQXZCLEVBQWtDLENBQWxDLEVBQTRDO0FBQzNDLFNBQUssWUFBTCxHQUFvQixDQUFwQixJQUF5QjtBQUN4QixVQUFJLEVBQUUsMkRBQVMsQ0FBQyxNQURRO0FBRXhCLE9BQUMsR0FGdUI7QUFHeEIsT0FBQyxFQUFFLGdGQUFhLENBQUMsQ0FBRCxDQUFiLEdBQW1CLENBQW5CLEdBQXVCO0FBSEYsS0FBekI7QUFLQSxXQUFPLElBQVA7QUFDQSxHQVBNOztBQVFSO0FBQUMsQ0FwQkQsQ0FBNEMsOERBQTVDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUNKQTtBQUNBO0FBRUEsSUFBSSxTQUFTLEdBQUcsQ0FBaEI7O0FBRUE7QUFBQTtBQUFBO0FBU0MsaUNBQVksT0FBWixFQUFrQyxJQUFsQyxFQUErRDtBQUE3QjtBQUFBO0FBQTZCOztBQUp2RCxtQkFBbUIsRUFBbkI7QUFLUCxTQUFLLEdBQUwsR0FBVyxFQUFFLFNBQWI7QUFDQSxTQUFLLEtBQUwsR0FBYSxJQUFiO0FBQ0EsU0FBSyxPQUFMLEdBQWUsT0FBZjtBQUNBLFNBQUssa0JBQUwsR0FBMEIseUZBQW9CLENBQUMsSUFBRCxDQUE5QztBQUNBOztBQUVELHdCQUFJLCtCQUFKLEVBQUksSUFBSixFQUFNO1NBQU47QUFDQyxhQUFPLEtBQUssR0FBWjtBQUNBLEtBRks7b0JBQUE7O0FBQUEsR0FBTjtBQUlBLHdCQUFJLCtCQUFKLEVBQUksTUFBSixFQUFRO1NBQVI7QUFDQyxhQUFPLEtBQUssS0FBWjtBQUNBLEtBRk87b0JBQUE7O0FBQUEsR0FBUjtBQUlBLHdCQUFJLCtCQUFKLEVBQUksbUJBQUosRUFBcUI7U0FBckI7QUFDQyxhQUFPLEtBQUssa0JBQVo7QUFDQSxLQUZvQjtvQkFBQTs7QUFBQSxHQUFyQjs7QUFJTyw0REFBUDtBQUNDLFdBQU8sS0FBSyxrQkFBTCxDQUF3QixrQkFBeEIsQ0FBMkMsS0FBSyxPQUFoRCxDQUFQO0FBQ0EsR0FGTTs7QUFJQSxrREFBUDtBQUFBOztBQUNDLFFBQUksS0FBSyxPQUFULEVBQWtCO0FBQ2pCLFVBQU0sS0FBSyxHQUFHLEtBQUssdUJBQUwsRUFBZDtBQUNBLFlBQU0sQ0FBQyxPQUFQLENBQWUsS0FBZixFQUFzQixPQUF0QixDQUE4QixVQUFDLEVBQUQsRUFBYTtZQUFYLFc7WUFBSyxhOztBQUNwQyxhQUFJLENBQUMsT0FBTCxDQUFjLFlBQWQsQ0FBMkIsR0FBM0IsRUFBZ0MsS0FBaEM7QUFDQSxPQUZEO0FBR0E7O0FBRUQsV0FBTyxJQUFQO0FBQ0EsR0FUTTs7QUFXQSw4Q0FBUDtBQUNDLFdBQU8sS0FBSyxPQUFMLENBQWEsR0FBYixDQUFpQixpQkFBSztBQUFJO0FBQWMsS0FBeEMsQ0FBUDtBQUNBLEdBRk07O0FBSUcsaURBQVY7QUFDQyxXQUFPLEtBQUssT0FBWjtBQUNBLEdBRlM7QUFJVjs7Ozs7QUFHTyw4Q0FBUDtBQUNDLFdBQU8sSUFBUDtBQUNBLEdBRk07O0FBSUcsZ0RBQVYsVUFBc0IsS0FBdEIsRUFBb0MsUUFBcEMsRUFBNkQ7QUFBekI7QUFBQTtBQUF5Qjs7QUFDNUQsUUFBSSxDQUFDLFFBQUwsRUFBZTtBQUNkLFdBQUssa0NBQUw7QUFDQTs7QUFFRCxTQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCLEtBQWxCOztBQUNBLFNBQUssa0JBQUwsQ0FBd0IsbUJBQXhCLENBQTRDLEtBQUssT0FBakQ7QUFDQSxHQVBTOztBQVNILDBDQUFQLFVBQWEsYUFBYixFQUFrQztBQUFyQjtBQUFBO0FBQXFCOztBQUNqQyxTQUFLLE9BQUwsQ0FBYSxNQUFiLEdBQXNCLENBQXRCOztBQUNBLFFBQUksYUFBSixFQUFtQjtBQUNsQixXQUFLLGFBQUw7QUFDQTs7QUFDRCxXQUFPLElBQVA7QUFDQSxHQU5NOztBQVFHLHVFQUFWO0FBQ0MsU0FBSyxPQUFMLENBQWEsTUFBYixLQUF3QixDQUF4QixJQUE2QixLQUFLLE9BQUwsQ0FBYSxJQUFiLENBQWtCO0FBQUUsVUFBSSxFQUFFLDJEQUFTLENBQUMsTUFBbEI7QUFBMEIsT0FBQyxFQUFFLENBQTdCO0FBQWdDLE9BQUMsRUFBRTtBQUFuQyxLQUFsQixDQUE3QjtBQUNBLEdBRlM7O0FBSUgsMkNBQVAsVUFBYyxDQUFkLEVBQXlCLENBQXpCLEVBQWtDO0FBQ2pDLFFBQU0sS0FBSyxHQUFVO0FBQUUsVUFBSSxFQUFFLDJEQUFTLENBQUMsTUFBbEI7QUFBMEIsT0FBQyxHQUEzQjtBQUE2QixPQUFDLEdBQTlCO0FBQWdDLFVBQUksRUFBRTtBQUF0QyxLQUFyQjtBQUNBLFNBQUssV0FBTCxDQUFpQixLQUFqQixFQUF3QixJQUF4QjtBQUNBLFdBQU8sSUFBUDtBQUNBLEdBSk07O0FBTUEsK0NBQVA7QUFDQyxXQUFPLEtBQUssT0FBWjtBQUNBLEdBRk07O0FBR1I7QUFBQyxDQXhGRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0xBO0FBQ0E7QUFDQTs7QUFFQTtBQUFBO0FBQUE7QUFBQSxnQ0FHQzs7QUFBRDtBQUFDLENBSEQ7Ozs7QUFLQTtBQUFBO0FBQUE7QUFBK0I7O0FBRzlCLDRCQUFZLFlBQVosRUFBa0M7QUFBbEMsZ0JBQ0MscUJBQU8sSUFEUjs7QUFFQyxTQUFJLENBQUMsWUFBTCxHQUFvQixZQUFwQjs7QUFDQTs7QUFFTSxtREFBUCxVQUEyQixNQUEzQixFQUEwQztBQUN6QyxRQUFNLFdBQVcsR0FBRyxLQUFLLFlBQUwsQ0FBa0IsTUFBbEIsR0FBMkIsQ0FBL0M7O0FBQ0EsUUFBSSxXQUFXLEtBQUssSUFBSSxDQUFDLEtBQUwsQ0FBVyxXQUFYLENBQXBCLEVBQTZDO0FBQzVDLGFBQU8sTUFBTSxDQUFDLE1BQVAsS0FBa0IsV0FBekI7QUFDQSxLQUp3QyxDQU16Qzs7O0FBQ0EsV0FDQyxNQUFNLENBQUMsTUFBUCxLQUFrQixJQUFJLENBQUMsSUFBTCxDQUFVLFdBQVYsQ0FBbEIsSUFBNEMsQ0FBQyxtRkFBYSxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBUCxHQUFnQixDQUFqQixDQUFOLENBQTBCLENBQTNCLENBRDNEO0FBR0EsR0FWTTs7QUFZQSxrREFBUCxVQUEwQixNQUExQixFQUF5QztBQUN4QyxRQUFNLEtBQUssR0FBUSxFQUFuQjtBQUNBLFFBQUksU0FBUyxHQUFXLENBQXhCOztBQUNBLFNBQUssSUFBSSxDQUFDLEdBQUcsQ0FBYixFQUFnQixDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQTNCLEVBQW1DLENBQUMsRUFBcEMsRUFBd0M7QUFDdkMsVUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLENBQUQsQ0FBcEI7QUFDQSxXQUFLLENBQUMsS0FBSyxZQUFMLENBQWtCLFNBQWxCLENBQUQsQ0FBTCxHQUFzQyxLQUFLLENBQUMsQ0FBNUM7O0FBQ0EsVUFBSSxLQUFLLENBQUMsSUFBTixLQUFlLHFEQUFTLENBQUMsTUFBekIsSUFBbUMsU0FBUyxHQUFHLENBQVosR0FBZ0IsS0FBSyxZQUFMLENBQWtCLE1BQXpFLEVBQWlGO0FBQ2hGLGFBQUssQ0FBQyxLQUFLLFlBQUwsQ0FBa0IsRUFBRSxTQUFwQixDQUFELENBQUwsR0FBd0MsS0FBSyxDQUFDLENBQTlDO0FBQ0E7O0FBQ0QsUUFBRSxTQUFGO0FBQ0E7O0FBQ0QsV0FBTyxLQUFQO0FBQ0EsR0FaTTs7QUFhUjtBQUFDLENBakNELENBQStCLGlCQUEvQjs7QUFtQ0E7QUFBQTtBQUFBO0FBQThCOztBQUM3QjtXQUNDLHFCQUFPLEk7QUFDUDs7QUFDTSxrREFBUDtBQUNDLFdBQU8sSUFBUDtBQUNBLEdBRk07O0FBR0EsaURBQVAsVUFBMEIsTUFBMUIsRUFBeUM7QUFDeEMsV0FBTyxNQUFNLENBQUMsTUFBUCxDQUNOLFVBQUMsR0FBRCxFQUFXLEtBQVgsRUFBZ0I7QUFDZixTQUFHLENBQUMsTUFBSixDQUFXLElBQVgsQ0FBZ0IsS0FBSyxDQUFDLENBQXRCO0FBQ0EsU0FBRyxDQUFDLE1BQUosQ0FBVyxJQUFYLENBQWdCLEtBQUssQ0FBQyxDQUF0QjtBQUNBLGFBQU8sR0FBUDtBQUNBLEtBTEssRUFNTjtBQUFFLFlBQU0sRUFBRTtBQUFWLEtBTk0sQ0FBUDtBQVFBLEdBVE07O0FBVVI7QUFBQyxDQWpCRCxDQUE4QixpQkFBOUI7O0FBbUJBLElBQU0sZUFBZSxHQUFHLElBQUksZUFBSixFQUF4QixDLENBRUE7O0FBQ0EsSUFBTSx1QkFBdUIsR0FBRyw0RUFBVyxDQUMxQztBQUNDLFFBQU0sRUFBRSxnQkFBQyxFQUFELEVBQXNCO1FBQW5CLFE7UUFBRyxRO1FBQUcsYztBQUFrQixpQkFBRyxJQUFJLEdBQUcsR0FBSCxHQUFTLEdBQWhCLElBQXNCLENBQXRCLEdBQXVCLEdBQXZCLEdBQTJCLENBQTNCO0FBQThCLEdBRGxFO0FBRUMsa0JBQWdCLEVBQUUsMEJBQUMsRUFBRCxFQUE2QztRQUExQyxnQjtRQUFPLGdCO1FBQU8sUTtRQUFHLFE7QUFDckMsaUJBQUksS0FBSixHQUFTLEdBQVQsR0FBYSxLQUFiLEdBQWtCLEdBQWxCLEdBQXNCLENBQXRCLEdBQXVCLEdBQXZCLEdBQTJCLENBQTNCO0FBQThCLEdBSGhDO0FBSUMsY0FBWSxFQUFFLHNCQUFDLEVBQUQsRUFBeUQ7UUFBdEQsZ0I7UUFBTyxnQjtRQUFPLGtCO1FBQVEsa0I7UUFBUSxRO1FBQUcsUTtBQUNqRCxpQkFBSSxLQUFKLEdBQVMsR0FBVCxHQUFhLEtBQWIsR0FBa0IsR0FBbEIsR0FBc0IsTUFBdEIsR0FBNEIsR0FBNUIsR0FBZ0MsTUFBaEMsR0FBc0MsR0FBdEMsR0FBMEMsQ0FBMUMsR0FBMkMsR0FBM0MsR0FBK0MsQ0FBL0M7QUFBa0Q7QUFMcEQsQ0FEMEMsRUFRMUMsVUFBQyxLQUFELEVBQWE7QUFDWixRQUFNLHdEQUFzRCxLQUFLLENBQUMsSUFBbEU7QUFDQSxDQVZ5QyxDQUEzQzs7QUFhQTtBQUFBO0FBQUE7QUFBb0M7O0FBQ25DO1dBQ0MscUJBQU8sSTtBQUNQOztBQUNNLHdEQUFQO0FBQ0MsV0FBTyxJQUFQO0FBQ0EsR0FGTTs7QUFHQSx1REFBUCxVQUEwQixNQUExQixFQUF5QztBQUN4QyxRQUFNLEtBQUssR0FBVSxNQUFNLENBQUMsQ0FBRCxDQUEzQjtBQUNBLFdBQU87QUFDTixPQUFDLEVBQUUsTUFBTSxDQUNQLEdBREMsQ0FDRyxVQUFDLENBQUQsRUFBSSxLQUFKLEVBQVM7QUFDYixZQUNDLEtBQUssS0FBSyxNQUFNLENBQUMsTUFBUCxHQUFnQixDQUExQixJQUNBLENBQUMsQ0FBQyxJQUFGLEtBQVcscURBQVMsQ0FBQyxNQURyQixJQUVBLENBQUMsQ0FBQyxDQUFGLEtBQVEsS0FBSyxDQUFDLENBRmQsSUFHQSxDQUFDLENBQUMsQ0FBRixLQUFRLEtBQUssQ0FBQyxDQUpmLEVBS0U7QUFDRDtBQUNBLGlCQUFPLEdBQVA7QUFDQTs7QUFDRCxlQUFPLHVCQUF1QixDQUFDLENBQUMsQ0FBQyxJQUFILENBQXZCLENBQWdDLENBQWhDLENBQVA7QUFDQSxPQVpDLEVBYUQsSUFiQyxDQWFJLEdBYko7QUFERyxLQUFQO0FBZ0JBLEdBbEJNOztBQW1CUjtBQUFDLENBMUJELENBQW9DLGlCQUFwQyxFLENBNEJBOzs7QUFDTyxJQUFNLG9CQUFvQixHQUFHLDRFQUFXLENBQW9CO0FBQ2xFLFFBQU0sRUFBRSxJQUFJLGdCQUFKLENBQXFCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxHQUFiLENBQXJCLENBRDBEO0FBRWxFLFNBQU8sRUFBRSxJQUFJLGdCQUFKLENBQXFCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLENBQXJCLENBRnlEO0FBR2xFLE1BQUksRUFBRSxJQUFJLGdCQUFKLENBQXFCLENBQUMsSUFBRCxFQUFPLElBQVAsRUFBYSxJQUFiLEVBQW1CLElBQW5CLENBQXJCLENBSDREO0FBSWxFLE1BQUksRUFBRSxJQUFJLHFCQUFKLEVBSjREO0FBS2xFLFNBQU8sRUFBRSxlQUx5RDtBQU1sRSxVQUFRLEVBQUUsZUFOd0Q7QUFPbEUsTUFBSSxFQUFFLElBQUksZ0JBQUosQ0FBcUIsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLE9BQVgsRUFBb0IsUUFBcEIsRUFBOEIsSUFBOUIsRUFBb0MsSUFBcEMsQ0FBckI7QUFQNEQsQ0FBcEIsQ0FBeEMsQzs7Ozs7Ozs7Ozs7O0FDM0dQO0FBQUE7QUFBQTtBQUFBO0FBQ0E7O0FBT0E7QUFBQTtBQUFBO0FBY0MsOEJBQVksV0FBWixFQUF3QztBQWJoQyxtQkFBbUIsRUFBbkI7QUFFQSwyQkFBNEIsRUFBNUI7QUFDQSxzQ0FBdUMsRUFBdkMsQ0FVZ0MsQ0FSeEM7O0FBQ1EscUNBQXNDLEVBQXRDO0FBQ0Esd0JBQXVCLENBQXZCO0FBRUEsaUNBQWlDLEtBQWpDO0FBRUEsc0JBQXdCLEVBQXhCO0FBR1AsU0FBSyxZQUFMLEdBQW9CLFdBQXBCO0FBQ0E7O0FBRUQsd0JBQVcsNEJBQVgsRUFBVyxZQUFYLEVBQXFCO1NBQXJCO0FBQ0MsYUFBTyxDQUFDLENBQUMsS0FBSyxPQUFkO0FBQ0EsS0FGb0I7b0JBQUE7O0FBQUEsR0FBckI7QUFJQSx3QkFBVyw0QkFBWCxFQUFXLFFBQVgsRUFBaUI7U0FBakI7QUFDQyxhQUFPLEtBQUssT0FBWjtBQUNBLEtBRmdCO29CQUFBOztBQUFBLEdBQWpCO0FBSUEsd0JBQVcsNEJBQVgsRUFBVyxhQUFYLEVBQXNCO1NBQXRCO0FBQ0MsYUFBTyxLQUFLLFlBQVo7QUFDQSxLQUZxQjtvQkFBQTs7QUFBQSxHQUF0QjtBQUlBLHdCQUFXLDRCQUFYLEVBQVcsZ0JBQVgsRUFBeUI7U0FBekI7QUFDQyxhQUFPLEtBQUssZUFBWjtBQUNBLEtBRndCO29CQUFBOztBQUFBLEdBQXpCO0FBSUEsd0JBQVcsNEJBQVgsRUFBVywyQkFBWCxFQUFvQztTQUFwQztBQUNDLGFBQU8sS0FBSywwQkFBWjtBQUNBLEtBRm1DO29CQUFBOztBQUFBLEdBQXBDO0FBSUEsd0JBQVcsNEJBQVgsRUFBVywwQkFBWCxFQUFtQztTQUFuQztBQUNDLGFBQU8sS0FBSyx5QkFBWjtBQUNBLEtBRmtDO29CQUFBOztBQUFBLEdBQW5DO0FBSUEsd0JBQVcsNEJBQVgsRUFBVyxhQUFYLEVBQXNCO1NBQXRCO0FBQ0MsYUFBTyxLQUFLLFlBQVo7QUFDQSxLQUZxQjtvQkFBQTs7QUFBQSxHQUF0QjtBQUlBLHdCQUFXLDRCQUFYLEVBQVcsUUFBWCxFQUFpQjtTQUFqQjtBQUNDLGFBQU8sS0FBSyxPQUFaO0FBQ0EsS0FGZ0I7b0JBQUE7O0FBQUEsR0FBakI7QUFJQSx3QkFBVyw0QkFBWCxFQUFXLFlBQVgsRUFBcUI7U0FBckI7QUFDQyxhQUFPLEtBQUssVUFBWjtBQUNBLEtBRm9CO29CQUFBOztBQUFBLEdBQXJCO0FBSUEsd0JBQVcsNEJBQVgsRUFBVyxzQkFBWCxFQUErQjtTQUEvQjtBQUNDLGFBQU8sS0FBSyxxQkFBWjtBQUNBLEtBRjhCO29CQUFBOztBQUFBLEdBQS9CO0FBSUE7Ozs7O0FBSU8sMkNBQVAsVUFBaUIsTUFBakIsRUFBZ0M7QUFDL0IsU0FBSyxPQUFMLEdBQWUsTUFBZjtBQUNBLFNBQUssZUFBTCxDQUFxQixNQUFyQixHQUE4QixDQUE5QixDQUYrQixDQUcvQjs7QUFDQSxTQUFLLFlBQUwsR0FBb0IsQ0FBcEI7QUFDQSxTQUFLLDBCQUFMLENBQWdDLE1BQWhDLEdBQXlDLENBQXpDLENBTCtCLENBTy9COztBQUNBLFNBQUssVUFBTCxDQUFnQixNQUFoQixHQUF5QixNQUFNLENBQUMsTUFBUCxLQUFrQixDQUFsQixHQUFzQixFQUF0QixHQUEyQixDQUFDLE1BQU0sQ0FBQyxDQUFELENBQU4sQ0FBVSxDQUFYLEVBQWMsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQXhCLENBQXBEO0FBRUEsUUFBSSxJQUFJLEdBQUcsQ0FBWDtBQUNBLFFBQUksSUFBSSxHQUFHLENBQVgsQ0FYK0IsQ0FhL0I7O0FBQ0EsU0FBSyxxQkFBTCxHQUNDLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLENBQWhCLElBQ0EsTUFBTSxDQUFDLENBQUQsQ0FBTixDQUFVLENBQVYsS0FBZ0IsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLENBQWpCLENBQU4sQ0FBMEIsQ0FEMUMsSUFFQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVUsQ0FBVixLQUFnQixNQUFNLENBQUMsTUFBTSxDQUFDLE1BQVAsR0FBZ0IsQ0FBakIsQ0FBTixDQUEwQixDQUgzQztBQUtBLFFBQUksUUFBUSxHQUFHLENBQWY7O0FBRUEsU0FBSyxJQUFJLFVBQVUsR0FBRyxDQUF0QixFQUF5QixVQUFVLEdBQUcsTUFBTSxDQUFDLE1BQTdDLEVBQXFELFVBQVUsRUFBL0QsRUFBbUU7QUFDbEUsVUFBTSxLQUFLLEdBQUcsTUFBTSxDQUFDLFVBQUQsQ0FBcEI7QUFFQSxVQUFNLGdCQUFnQixHQUFHLDBFQUFzQixDQUFDLEtBQUssQ0FBQyxJQUFOLENBQVcsUUFBWCxFQUFELENBQS9DO0FBRUEsVUFBTSx3QkFBd0IsR0FDN0IsS0FBSyxxQkFBTCxJQUE4QixVQUFVLEtBQUssTUFBTSxDQUFDLE1BQVAsR0FBZ0IsQ0FEOUQ7QUFHQSxVQUFNLE1BQU0sR0FBRyw0RUFBZ0IsQ0FBQyxLQUFELENBQS9COztBQUNBLFdBQUssSUFBSSxDQUFDLEdBQUcsQ0FBYixFQUFnQixDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQTNCLEVBQW1DLENBQUMsSUFBSSxDQUF4QyxFQUEyQztBQUMxQyxZQUFJLENBQUMsd0JBQUQsSUFBNkIsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFQLEdBQWdCLENBQXJELEVBQXdEO0FBQ3ZELFlBQUUsUUFBRixDQUR1RCxDQUV2RDs7QUFDQSxjQUFJLElBQUksTUFBTSxDQUFDLENBQUQsQ0FBZDs7QUFDQSxjQUFJLG1GQUFhLENBQUMsTUFBTSxDQUFDLENBQUMsR0FBRyxDQUFMLENBQVAsQ0FBakIsRUFBa0M7QUFDakMsZ0JBQUksSUFBSSxNQUFNLENBQUMsQ0FBQyxHQUFHLENBQUwsQ0FBZDtBQUNBO0FBQ0Q7QUFDRCxPQWxCaUUsQ0FvQmxFOzs7QUFDQSxVQUFJLFVBQVUsR0FBRyxDQUFqQixFQUFvQjtBQUNuQixZQUFNLFNBQVMsR0FBVSxNQUFNLENBQUMsVUFBVSxHQUFHLENBQWQsQ0FBL0I7QUFDQSxZQUFNLDhCQUE4QixHQUFHLEtBQUssVUFBTCxDQUFnQixNQUFoQixDQUF1QixNQUE5RDtBQUNBLFlBQU0sYUFBYSxHQUFXLGdCQUFnQixDQUM3QyxTQUQ2QyxFQUU3QyxLQUY2QyxFQUc3QyxLQUFLLFVBQUwsQ0FBZ0IsTUFINkIsQ0FBOUM7O0FBS0EsYUFBSyx5QkFBTCxDQUErQixJQUEvQixDQUNDLEtBQUssVUFBTCxDQUFnQixNQUFoQixDQUF1QixNQUF2QixHQUFnQyw4QkFEakM7O0FBR0EsYUFBSyxlQUFMLENBQXFCLElBQXJCLENBQTBCLGFBQTFCOztBQUNBLGFBQUssMEJBQUwsQ0FBZ0MsSUFBaEMsQ0FDQyxDQUFDLEtBQUssMEJBQUwsQ0FBZ0MsS0FBSywwQkFBTCxDQUFnQyxNQUFoQyxHQUF5QyxDQUF6RSxLQUNBLENBREQsSUFDTSxhQUZQOztBQUlBLGFBQUssWUFBTCxJQUFxQixhQUFyQjtBQUNBO0FBQ0QsS0E1RDhCLENBOEQvQjs7O0FBQ0EsU0FBSyxPQUFMLEdBQWU7QUFDZCxPQUFDLEVBQUUsSUFBSSxHQUFHLFFBREk7QUFFZCxPQUFDLEVBQUUsSUFBSSxHQUFHO0FBRkksS0FBZjtBQUlBLEdBbkVNOztBQXFFQSx1REFBUCxVQUE2QixNQUE3QixFQUE4QyxFQUE5QyxFQUF5RCxXQUF6RCxFQUE0RTtBQUMzRSxlQUFXLEdBQUcsV0FBVyxJQUFJLEtBQUssT0FBbEM7QUFFQSxXQUFPLEtBQVA7QUFDQSxHQUpNOztBQUtSO0FBQUMsQ0F4SUQ7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFBQTtBQUFBLElBQVksU0FBWjs7QUFBQSxXQUFZLFNBQVosRUFBcUI7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBTkQsRUFBWSxTQUFTLEtBQVQsU0FBUyxNQUFyQixFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0hBO0FBQ0E7QUFDQTtBQUVBOzs7Ozs7Ozs7QUFRTSxTQUFVLG9CQUFWLENBQ0wsQ0FESyxFQUVMLEtBRkssRUFHTCxTQUhLLEVBSUwsT0FKSyxFQUtMLEdBTEssRUFLTTtBQUVYLE1BQU0sRUFBRSxHQUFHLENBQUMsR0FBRyxDQUFmO0FBQ0EsTUFBTSxFQUFFLEdBQUcsRUFBRSxHQUFHLENBQWhCO0FBQ0EsU0FDQyxLQUFLLEdBQ0wsQ0FBQyxDQUFDLEtBQUQsR0FBUyxDQUFULEdBQWEsQ0FBQyxJQUFJLElBQUksS0FBSixHQUFZLEtBQUssR0FBRyxDQUF4QixDQUFmLElBQTZDLENBRDdDLEdBRUEsQ0FBQyxJQUFJLFNBQUosR0FBZ0IsQ0FBQyxJQUFJLENBQUMsQ0FBRCxHQUFLLFNBQUwsR0FBaUIsU0FBUyxHQUFHLENBQVosR0FBZ0IsQ0FBckMsQ0FBbEIsSUFBNkQsQ0FGN0QsR0FHQSxDQUFDLE9BQU8sR0FBRyxDQUFWLEdBQWMsT0FBTyxHQUFHLENBQVYsR0FBYyxDQUE3QixJQUFrQyxFQUhsQyxHQUlBLEdBQUcsR0FBRyxFQUxQO0FBT0E7QUFFSyxTQUFVLHNCQUFWLENBQWlDLEVBQWpDLEVBQTRDLEVBQTVDLEVBQXVELGFBQXZELEVBQXlFO0FBQWxCO0FBQUE7QUFBa0I7O0FBQzlFLE1BQU0sWUFBWSxHQUFHLEtBQUssYUFBYSxHQUFHLENBQXJCLENBQXJCO0FBQ0EsTUFBTSxnQkFBZ0IsR0FBWSxFQUFsQzs7QUFDQSxPQUFLLElBQUksQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBQyxHQUFHLGFBQXBCLEVBQW1DLENBQUMsRUFBcEMsRUFBd0M7QUFDdkMsb0JBQWdCLENBQUMsSUFBakIsQ0FBc0I7QUFDckIsT0FBQyxFQUFFLG9CQUFvQixDQUN0QixZQUFZLEdBQUcsQ0FETyxFQUV0QixFQUFFLENBQUMsQ0FGbUIsRUFHckIsRUFBdUIsQ0FBQyxLQUhILEVBSXJCLEVBQXVCLENBQUMsTUFKSCxFQUt0QixFQUFFLENBQUMsQ0FMbUIsQ0FERjtBQVFyQixPQUFDLEVBQUUsb0JBQW9CLENBQ3RCLFlBQVksR0FBRyxDQURPLEVBRXRCLEVBQUUsQ0FBQyxDQUZtQixFQUdyQixFQUF1QixDQUFDLEtBSEgsRUFJckIsRUFBdUIsQ0FBQyxNQUpILEVBS3RCLEVBQUUsQ0FBQyxDQUxtQjtBQVJGLEtBQXRCO0FBZ0JBOztBQUNELFNBQU8sZ0JBQVA7QUFDQTtBQUVLLFNBQVUsMEJBQVYsQ0FDTCxFQURLLEVBRUwsRUFGSyxFQUdMLGFBSEssRUFJTCxXQUpLLEVBSVU7QUFEZjtBQUFBO0FBQWtCOztBQUNsQjtBQUFBO0FBQWU7O0FBRVA7QUFBQSxNQUFPLFNBQVA7QUFDQTtBQUFBLE1BQVcsYUFBWDtBQUFBLE1BQXNCLFNBQXRCO0FBQUEsTUFBNkIsU0FBN0I7QUFDUixNQUFJLFFBQVEsR0FBVyxFQUFFLEdBQUcsRUFBNUI7QUFDQSxNQUFJLFFBQVEsR0FBVyxFQUFFLEdBQUcsRUFBNUI7QUFDQSxNQUFJLFFBQVEsR0FBVyxFQUFFLEdBQUcsRUFBNUI7QUFDQSxNQUFJLFFBQVEsR0FBVyxFQUFFLEdBQUcsRUFBNUI7QUFDQSxNQUFJLEVBQUosRUFBUSxFQUFSO0FBQ0EsTUFBSSxLQUFLLEdBQUcsQ0FBQyxLQUFiO0FBQ0EsTUFBSSxLQUFLLEdBQUcsQ0FBQyxLQUFiO0FBQ0EsTUFBSSxHQUFHLEdBQVksQ0FBQztBQUFFLEtBQUMsRUFBRSxFQUFMO0FBQVMsS0FBQyxFQUFFO0FBQVosR0FBRCxDQUFuQjs7QUFDQSxPQUFLLElBQUksQ0FBQyxHQUFHLENBQWIsRUFBZ0IsQ0FBQyxHQUFHLGFBQWEsR0FBRyxDQUFwQyxFQUF1QyxDQUFDLEVBQXhDLEVBQTRDO0FBQzNDLFFBQUksQ0FBQyxHQUFHLENBQUMsR0FBRyxhQUFaO0FBQ0EsTUFBRSxHQUFHLEVBQUUsR0FBRyxRQUFRLEdBQUcsQ0FBckI7QUFDQSxNQUFFLEdBQUcsRUFBRyxHQUFHLFFBQVEsR0FBRyxDQUF0QjtBQUNBLFFBQUksQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFDLEVBQUUsR0FBRyxRQUFRLEdBQUcsQ0FBaEIsR0FBb0IsRUFBckIsSUFBMkIsQ0FBeEM7QUFDQSxRQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxFQUFFLEdBQUcsUUFBUSxHQUFHLENBQWhCLEdBQW9CLEVBQXJCLElBQTJCLENBQXhDO0FBQ0EsUUFBSSxFQUFFLEdBQUcsQ0FBQyxHQUFHLEtBQWI7QUFDQSxRQUFJLEVBQUUsR0FBRyxDQUFDLEdBQUcsS0FBYjs7QUFDQSxRQUFJLEVBQUUsR0FBRyxFQUFMLEdBQVUsRUFBRSxHQUFHLEVBQWYsR0FBb0IsV0FBeEIsRUFBcUM7QUFDcEMsU0FBRyxDQUFDLElBQUosQ0FBUztBQUFFLFNBQUMsRUFBRSxDQUFMO0FBQVEsU0FBQyxFQUFFO0FBQVgsT0FBVDtBQUNBLFdBQUssR0FBRyxDQUFSO0FBQ0EsV0FBSyxHQUFHLENBQVI7QUFDQTtBQUNEOztBQUNELEtBQUcsQ0FBQyxJQUFKLENBQVM7QUFBRSxLQUFDLEVBQUUsRUFBTDtBQUFTLEtBQUMsRUFBRTtBQUFaLEdBQVQ7QUFDQSxTQUFPLEdBQVA7QUFDQTtBQUVLLFNBQVUsd0JBQVYsQ0FBbUMsTUFBbkMsRUFBa0QsTUFBbEQsRUFBOEU7QUFDM0U7QUFBQSxNQUFPLGFBQVA7QUFDQTtBQUFBLE1BQVcsaUJBQVg7QUFBQSxNQUFzQixhQUF0QjtBQUFBLE1BQTZCLGFBQTdCO0FBQ1IsTUFBSSxDQUFKO0FBQ0EsTUFBSSxDQUFKO0FBQ0EsTUFBSSxDQUFKO0FBQ0EsTUFBSSxDQUFKO0FBQ0EsTUFBTSxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQWpCO0FBQ0EsTUFBTSxHQUFHLEdBQUcsRUFBRSxHQUFHLENBQWpCO0FBQ0EsTUFBTSxDQUFDLEdBQUcsRUFBRSxHQUFHLEdBQUwsR0FBVyxFQUFyQjtBQUNBLE1BQU0sRUFBRSxHQUFHLEVBQUcsR0FBRyxHQUFOLEdBQVksRUFBdkI7QUFDQSxNQUFNLENBQUMsR0FBRyxHQUFHLEdBQUcsSUFBSSxFQUFwQjtBQUNBLE1BQU0sRUFBRSxHQUFHLEdBQUcsR0FBRyxJQUFJLEVBQXJCO0FBQ0EsTUFBSSxFQUFFLEdBQUksQ0FBQyxHQUFHLEtBQUssQ0FBQyxHQUFHLENBQUosR0FBUSxFQUFFLEdBQUcsRUFBbEIsQ0FBZDtBQUNBLElBQUUsSUFBSSxDQUFDLEdBQUcsS0FBSyxDQUFDLEdBQUcsQ0FBSixHQUFRLEVBQUUsR0FBRyxFQUFsQixDQUFWO0FBQ0EsSUFBRSxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBSixHQUFRLEVBQUUsR0FBRyxFQUF2QjtBQUNBLElBQUUsR0FBRyxJQUFJLElBQUksQ0FBQyxJQUFMLENBQVUsRUFBVixDQUFUO0FBQ0EsTUFBTSxFQUFFLEdBQUcsSUFBSSxDQUFKLElBQVMsQ0FBQyxHQUFHLElBQUksQ0FBQyxJQUFMLENBQVUsQ0FBVixDQUFiLENBQVg7QUFDQSxNQUFNLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBZjtBQUNBLEdBQUMsR0FBRyxJQUFJLENBQUosR0FBUSxDQUFSLEdBQVksQ0FBQyxHQUFHLENBQXBCO0FBQ0EsR0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLElBQUwsQ0FBVSxDQUFWLENBQVI7QUFDQSxTQUFPLENBQUMsRUFBRSxHQUFHLEVBQUwsR0FBVSxDQUFDLEdBQUcsQ0FBSixJQUFTLEVBQUUsR0FBRyxDQUFkLENBQVYsR0FBNkIsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsQ0FBQyxJQUFJLENBQUosR0FBUSxFQUFSLEdBQWEsRUFBZCxLQUFxQixFQUFFLEdBQUcsQ0FBMUIsQ0FBVCxDQUFsQyxLQUE2RSxJQUFJLEVBQWpGLENBQVA7QUFDQTtBQUVLLFNBQVUsb0JBQVYsQ0FDTCxFQURLLEVBRUwsRUFGSyxFQUdMLGFBSEssRUFJTCxpQkFKSyxFQUl1QjtBQUQ1QjtBQUFBO0FBQWtCOztBQUdsQixNQUFNLGdCQUFnQixHQUFZLHNCQUFzQixDQUFDLEVBQUQsRUFBSyxFQUFMLEVBQVMsYUFBVCxDQUF4RDtBQUNBLE1BQUksU0FBUyxHQUFHLENBQWhCOztBQUVBLE9BQUssSUFBSSxDQUFDLEdBQUcsQ0FBYixFQUFnQixDQUFDLEdBQUcsZ0JBQWdCLENBQUMsTUFBckMsRUFBNkMsQ0FBQyxFQUE5QyxFQUFrRDtBQUNqRCxRQUFJLGlCQUFKLEVBQXVCO0FBQ3RCLHVCQUFpQixDQUFDLElBQWxCLENBQXVCLGdCQUFnQixDQUFDLENBQUMsR0FBRyxDQUFMLENBQWhCLENBQXdCLENBQS9DO0FBQ0EsdUJBQWlCLENBQUMsSUFBbEIsQ0FBdUIsZ0JBQWdCLENBQUMsQ0FBQyxHQUFHLENBQUwsQ0FBaEIsQ0FBd0IsQ0FBL0M7QUFDQSx1QkFBaUIsQ0FBQyxJQUFsQixDQUF1QixnQkFBZ0IsQ0FBQyxDQUFELENBQWhCLENBQW9CLENBQTNDO0FBQ0EsdUJBQWlCLENBQUMsSUFBbEIsQ0FBdUIsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoQixDQUFvQixDQUEzQztBQUNBOztBQUNELGFBQVMsSUFBSSwyRUFBVyxDQUN2QixnQkFBZ0IsQ0FBQyxDQUFDLEdBQUcsQ0FBTCxDQUFoQixDQUF3QixDQURELEVBRXZCLGdCQUFnQixDQUFDLENBQUMsR0FBRyxDQUFMLENBQWhCLENBQXdCLENBRkQsRUFHdkIsZ0JBQWdCLENBQUMsQ0FBRCxDQUFoQixDQUFvQixDQUhHLEVBSXZCLGdCQUFnQixDQUFDLENBQUQsQ0FBaEIsQ0FBb0IsQ0FKRyxDQUF4QjtBQU1BOztBQUVELFNBQU8sU0FBUDtBQUNBLEMsQ0EyQkQ7O0FBQ0E7Ozs7QUFHTyxJQUFNLHVCQUF1QixHQUFHLDRFQUFXLENBQ2pEO0FBQ0MsUUFBTSxFQUFFLGdCQUFDLEtBQUQsRUFBZSxtQkFBZixFQUE0QyxhQUE1QyxFQUFnRTtBQUFLLFdBQUM7QUFDN0UsT0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQU4sR0FBVSxhQUFhLENBQUMsQ0FBekIsSUFBOEIsbUJBQTlCLEdBQW9ELGFBQWEsQ0FBQyxDQURRO0FBRTdFLE9BQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFOLEdBQVcsYUFBYSxDQUFDLENBQTFCLElBQWdDLG1CQUFoQyxHQUFzRCxhQUFhLENBQUM7QUFGTSxLQUFEO0FBRzNFLEdBSkg7QUFLQyxjQUFZLEVBQUUsc0JBQUMsS0FBRCxFQUFlLG1CQUFmLEVBQTRDLGFBQTVDLEVBQWdFO0FBQzdFLFFBQU0sRUFBRSxHQUFHLEtBQVg7QUFDQSxXQUFPO0FBQ04sT0FBQyxFQUFFLG9CQUFvQixDQUN0QixtQkFEc0IsRUFFdEIsYUFBYSxDQUFDLENBRlEsRUFHdEIsRUFBRSxDQUFDLEtBSG1CLEVBSXRCLEVBQUUsQ0FBQyxNQUptQixFQUt0QixFQUFFLENBQUMsQ0FMbUIsQ0FEakI7QUFRTixPQUFDLEVBQUUsb0JBQW9CLENBQ3RCLG1CQURzQixFQUV0QixhQUFhLENBQUMsQ0FGUSxFQUd0QixFQUFFLENBQUMsS0FIbUIsRUFJdEIsRUFBRSxDQUFDLE1BSm1CLEVBS3RCLEVBQUUsQ0FBQyxDQUxtQjtBQVJqQixLQUFQO0FBZ0JBO0FBdkJGLENBRGlELEVBNEJqRCxVQUFDLEtBQUQsRUFBYTtBQUNaLFFBQU0sZUFBYSxLQUFLLENBQUMsSUFBbkIsR0FBdUIsK0NBQTdCO0FBQ0EsQ0E5QmdELENBQTNDO0FBdUNBLElBQU0sc0JBQXNCLEdBQUcsNEVBQVcsQ0FDaEQ7QUFDQyxRQUFNLEVBQUUsZ0JBQUMsRUFBRCxFQUFZLEVBQVosRUFBdUIsU0FBdkIsRUFBMkM7QUFDbEQsUUFBSSxTQUFKLEVBQWU7QUFDZCxlQUFTLENBQUMsSUFBVixDQUFlLEVBQUUsQ0FBQyxDQUFsQjtBQUNBLGVBQVMsQ0FBQyxJQUFWLENBQWUsRUFBRSxDQUFDLENBQWxCO0FBQ0E7O0FBQ0QsV0FBTywyRUFBVyxDQUFDLEVBQUUsQ0FBQyxDQUFKLEVBQU8sRUFBRSxDQUFDLENBQUgsSUFBUSxDQUFmLEVBQWtCLEVBQUUsQ0FBQyxDQUFyQixFQUF3QixFQUFFLENBQUMsQ0FBSCxJQUFRLENBQWhDLENBQWxCO0FBQ0EsR0FQRjtBQVFDLGNBQVksRUFBRSxzQkFBQyxFQUFELEVBQVksRUFBWixFQUF1QixTQUF2QixFQUEyQztBQUN4RCwrQkFBb0IsQ0FBQyxFQUFELEVBQUssRUFBTCxFQUFTLEVBQVQsRUFBYSxTQUFiLENBQXBCO0FBQTJDO0FBVDdDLENBRGdELEVBY2hELFVBQUMsU0FBRCxFQUFtQixLQUFuQixFQUErQjtBQUM5QixRQUFNLGVBQWEsS0FBSyxDQUFDLElBQW5CLEdBQXVCLDhDQUE3QjtBQUNBLENBaEIrQyxDQUExQztBQW1CUCxJQUFNLElBQUksR0FBYSxJQUFJLEtBQUosQ0FBVSxDQUFWLENBQXZCO0FBQ0EsSUFBTSxJQUFJLEdBQWEsSUFBSSxLQUFKLENBQVUsQ0FBVixDQUF2QjtBQUNBLElBQU0sSUFBSSxHQUFhLElBQUksS0FBSixDQUFVLENBQVYsQ0FBdkI7QUFDQSxJQUFNLElBQUksR0FBYSxJQUFJLEtBQUosQ0FBVSxDQUFWLENBQXZCO0FBR0EsSUFBTSx3QkFBd0IsYUFDN0IsR0FBQyxxREFBUyxDQUFDLE1BQVgsSUFBb0IsVUFBQyxLQUFELEVBQWE7QUFDaEMsTUFBSSxDQUFDLENBQUQsQ0FBSixHQUFVLEtBQUssQ0FBQyxDQUFoQjtBQUNBLFNBQU8sSUFBUDtBQUNBLENBSjRCLEVBSzdCLEdBQUMscURBQVMsQ0FBQyxNQUFYLElBQW9CLFVBQUMsS0FBRCxFQUFhO0FBQ2hDLE1BQUksQ0FBQyxDQUFELENBQUosR0FBVSxLQUFLLENBQUMsQ0FBaEI7QUFDQSxNQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVUsS0FBSyxDQUFDLENBQWhCO0FBQ0EsU0FBTyxJQUFQO0FBQ0EsQ0FUNEIsRUFVN0IsR0FBQyxxREFBUyxDQUFDLGVBQVgsSUFBNkIsVUFBQyxLQUFELEVBQWE7QUFDekMsTUFBSSxDQUFDLENBQUQsQ0FBSixHQUFXLEtBQThCLENBQUMsQ0FBMUM7QUFDQSxNQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVcsS0FBOEIsQ0FBQyxDQUExQztBQUNBLE1BQUksQ0FBQyxDQUFELENBQUosR0FBVyxLQUE4QixDQUFDLEtBQTFDO0FBQ0EsTUFBSSxDQUFDLENBQUQsQ0FBSixHQUFXLEtBQThCLENBQUMsS0FBMUM7QUFDQSxTQUFPLElBQVA7QUFDQSxDQWhCNEIsRUFpQjdCLEdBQUMscURBQVMsQ0FBQyxXQUFYLElBQXlCLFVBQUMsS0FBRCxFQUFhO0FBQ3JDLE1BQUksQ0FBQyxDQUFELENBQUosR0FBVyxLQUEwQixDQUFDLENBQXRDO0FBQ0EsTUFBSSxDQUFDLENBQUQsQ0FBSixHQUFXLEtBQTBCLENBQUMsQ0FBdEM7QUFDQSxNQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVcsS0FBMEIsQ0FBQyxLQUF0QztBQUNBLE1BQUksQ0FBQyxDQUFELENBQUosR0FBVyxLQUEwQixDQUFDLEtBQXRDO0FBQ0EsTUFBSSxDQUFDLENBQUQsQ0FBSixHQUFXLEtBQTBCLENBQUMsTUFBdEM7QUFDQSxNQUFJLENBQUMsQ0FBRCxDQUFKLEdBQVcsS0FBMEIsQ0FBQyxNQUF0QztBQUNBLFNBQU8sSUFBUDtBQUNBLENBekI0QixFQTBCN0IsR0FBQyxxREFBUyxDQUFDLFlBQVgsSUFBMEI7QUFDekIsUUFBTSw4Q0FBTjtBQUNBLENBNUI0QixFQTZCN0IsRUE3QjZCLENBQTlCO0FBOEJPLElBQU0sZ0JBQWdCLEdBQUcsU0FBbkIsZ0JBQW1CLENBQUMsS0FBRCxFQUFhO0FBQzVDLGlDQUF3QixDQUFDLEtBQUssQ0FBQyxJQUFQLENBQXhCLENBQXFDLEtBQXJDO0FBQTJDLENBRHJDLEM7Ozs7Ozs7Ozs7OztBQ3RRUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDQTtBQUVBOztBQUNBLElBQU0sdUJBQXVCLEdBQUcseUVBQVcsQ0FDMUM7QUFDQyxRQUFNLEVBQUUsZ0JBQUMsUUFBRCxFQUFpQjtBQUFLLG1CQUFRLENBQUMsYUFBVDtBQUFnQztBQUQvRCxDQUQwQyxFQUkxQyxrRUFKMEMsQ0FBM0M7QUErRGMsU0FBVSxnQkFBVixDQUNiLElBRGEsRUFFYixTQUZhLEVBR2IsRUFIYSxFQUliLFVBSmEsRUFJYztBQUUzQixNQUFNLElBQUksR0FBRyxRQUFRLENBQUMsZUFBVCxDQUF5Qiw0QkFBekIsRUFBdUQsSUFBdkQsQ0FBYjtBQUVBLElBQUUsS0FBSyxJQUFJLENBQUMsRUFBTCxHQUFVLEVBQWYsQ0FBRjtBQUNBLFlBQVUsSUFBSSxJQUFJLENBQUMsWUFBTCxDQUFrQixPQUFsQixFQUEyQixVQUEzQixDQUFkO0FBQ0EsV0FBUyxJQUFJLHVCQUF1QixTQUFRLFNBQVIsRUFBdkIsQ0FBMEMsU0FBMUMsRUFBcUQsV0FBckQsQ0FBaUUsSUFBakUsQ0FBYjtBQUVBLFNBQU8sSUFBUDtBQUNBLEM7Ozs7Ozs7Ozs7OztBQ2hGRDtBQUFBO0FBQUE7QUFBQSxJQUFNLFVBQVUsR0FBYSxTQUF2QixVQUF1QixDQUFDLENBQUQsRUFBTztBQUFLO0FBQUMsQ0FBMUM7O0FBQ0EsSUFBTSxPQUFPLEdBQWEsU0FBcEIsT0FBb0IsSUFBUSxDQUFsQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ0RBO0FBRUEsSUFBTSxhQUFhLEdBQUcsaUVBQVcsQ0FDaEM7QUFDQyxRQUFNLEVBQUUsZ0JBQUMsR0FBRCxFQUFTO0FBQUssY0FBRyxLQUFIO0FBQVksR0FEbkM7QUFFQyxRQUFNLEVBQUUsZ0JBQUMsR0FBRCxFQUFZO0FBQUssWUFBQyxLQUFLLENBQU4sR0FBTSxDQUFOO0FBQVcsR0FGckM7QUFHQyxXQUFTLEVBQUU7QUFBTTtBQUFLO0FBSHZCLENBRGdDLEVBTWhDO0FBQU07QUFBSSxDQU5zQixDQUFqQztBQVNBLElBQU0sWUFBWSxHQUFHLGlFQUFXLENBQy9CO0FBQ0MsUUFBTSxFQUFFLGdCQUFDLEdBQUQsRUFBWTtBQUFLLGNBQUcsQ0FBQyxNQUFKO0FBQWdCLEdBRDFDO0FBRUMsUUFBTSxFQUFFLGdCQUFDLEdBQUQsRUFBWTtBQUFLLGdCQUFLLENBQUwsR0FBSyxDQUFMO0FBQVUsR0FGcEM7QUFHQyxXQUFTLEVBQUU7QUFBTTtBQUFJLEdBSHRCO0FBSUMsUUFBTSxFQUFFO0FBQU07QUFBSyxHQUpwQjtBQUtDLFFBQU0sRUFBRSxnQkFBQyxHQUFELEVBQVk7QUFDbkIsUUFBSSxHQUFHLEtBQUssSUFBWixFQUFrQjtBQUNqQixhQUFPLElBQVA7QUFDQSxLQUZELE1BRU8sSUFBSSxLQUFLLENBQUMsT0FBTixDQUFjLEdBQWQsQ0FBSixFQUF3QjtBQUM5QixhQUFPLEdBQUcsQ0FBQyxNQUFKLEtBQWUsQ0FBdEI7QUFDQTs7QUFDRCxXQUFPLE1BQU0sQ0FBQyxJQUFQLENBQVksR0FBWixFQUFpQixNQUFqQixLQUE0QixDQUFuQztBQUNBO0FBWkYsQ0FEK0I7QUFlL0I7QUFDQSxVQUFDLEdBQUQsRUFBUztBQUNSLFFBQU0sb0JBQWtCLEdBQWxCLEdBQXFCLHNDQUFyQixXQUFtRSxHQUFuRSxJQUFzRSxzQkFBNUU7QUFDQSxDQWxCOEIsQ0FBaEM7QUFxQkE7Ozs7OztBQUtBLElBQU0sYUFBYSxHQUFHLFNBQWhCLGFBQWdCLENBQUMsR0FBRCxFQUFTO0FBQUssc0JBQWEsU0FBUSxHQUFSLEVBQWI7QUFBOEIsQ0FBbEU7QUFFQTs7Ozs7Ozs7O0FBT0EsSUFBTSxpQkFBaUIsR0FBRyxTQUFwQixpQkFBb0I7QUFBQzs7T0FBQSxVLEVBQUEscUIsRUFBQSxJLEVBQWM7QUFBZDs7O0FBQW1CLGFBQUksQ0FBQyxLQUFMLENBQVcsYUFBWDtBQUF5QixDQUF2RTtBQUVBOzs7Ozs7OztBQU1BLElBQU0sdUJBQXVCLEdBQUcsU0FBMUIsdUJBQTBCLENBQUMsS0FBRCxFQUFhO0FBQUssY0FBSyxDQUFDLEtBQU47QUFBMEIsQ0FBNUU7QUFFQTs7Ozs7OztBQUtBLElBQU0sT0FBTyxHQUFHLFNBQVYsT0FBVSxDQUFDLEdBQUQsRUFBUztBQUFLLHFCQUFZLFNBQVEsR0FBUixFQUFaO0FBQTZCLENBQTNEOzs7Ozs7Ozs7Ozs7OztBQzdEQTtBQUFBO0FBQUE7QUFBQSxTQUFTLFdBQVQsQ0FBd0IsTUFBeEIsRUFBd0MsR0FBeEMsRUFBK0M7QUFDOUMsTUFBTSxPQUFPLEdBQUc7QUFDZixPQUFHLEVBQUUsYUFBQyxNQUFELEVBQWMsSUFBZCxFQUE0QztBQUNoRCxhQUFPLE1BQU0sQ0FBQyxJQUFELENBQU4sSUFBZ0IsR0FBdkI7QUFDQTtBQUhjLEdBQWhCO0FBTUEsU0FBTyxJQUFJLEtBQUosQ0FBVSxNQUFWLEVBQWtCLE9BQWxCLENBQVA7QUFDQTs7QUFFTSxJQUFNLFFBQVEsR0FBRyxNQUFNLENBQUMsTUFBUCxDQUFjLEVBQWQsQ0FBakI7Ozs7Ozs7Ozs7Ozs7QUNWUDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ08sSUFBTSx3Q0FBd0MsR0FBRyxrQkFBakQ7QUFFRCxTQUFVLFdBQVYsQ0FBc0IsRUFBdEIsRUFBa0MsRUFBbEMsRUFBOEMsRUFBOUMsRUFBMEQsRUFBMUQsRUFBb0U7QUFDekUsU0FBTyxJQUFJLENBQUMsSUFBTCxDQUFVLENBQUMsRUFBRSxHQUFHLEVBQU4sS0FBYSxFQUFFLEdBQUcsRUFBbEIsSUFBd0IsQ0FBQyxFQUFFLEdBQUcsRUFBTixLQUFhLEVBQUUsR0FBRyxFQUFsQixDQUFsQyxDQUFQO0FBQ0EsQyxDQUVEOztBQUNNLFNBQVUsbUJBQVYsQ0FBOEIsRUFBOUIsRUFBMEMsRUFBMUMsRUFBc0QsRUFBdEQsRUFBa0UsRUFBbEUsRUFBNEU7QUFDakYsU0FBTyxDQUFDLEVBQUUsR0FBRyxFQUFOLEtBQWEsRUFBRSxHQUFHLEVBQWxCLElBQXdCLENBQUMsRUFBRSxHQUFHLEVBQU4sS0FBYSxFQUFFLEdBQUcsRUFBbEIsQ0FBL0I7QUFDQTtBQUVLLFNBQVUsa0JBQVYsQ0FBNkIsS0FBN0IsRUFBNEMsTUFBNUMsRUFBMEQ7QUFDL0QsU0FBTyxDQUFDLEtBQUssR0FBRyxNQUFULElBQW1CLENBQTFCO0FBQ0E7QUFFSyxTQUFVLHNCQUFWLENBQWlDLE1BQWpDLEVBQStDO0FBQ3BELFNBQU8sSUFBSSxJQUFJLENBQUMsRUFBVCxHQUFjLE1BQXJCO0FBQ0E7QUFFSyxTQUFVLGdCQUFWLENBQ0wsRUFESyxFQUVMLEVBRkssRUFHTCxFQUhLLEVBSUwsRUFKSyxFQUtMLEVBTEssRUFNTCxFQU5LLEVBT0wsRUFQSyxFQVFMLEVBUkssRUFRSztBQUVWLE1BQUksRUFBSjtBQUFBLE1BQ0MsRUFERDtBQUFBLE1BRUMsS0FBSyxHQUFHLENBQUMsRUFBRSxHQUFHLEVBQU4sS0FBYSxFQUFFLEdBQUcsRUFBbEIsSUFBd0IsQ0FBQyxFQUFFLEdBQUcsRUFBTixLQUFhLEVBQUUsR0FBRyxFQUFsQixDQUZqQzs7QUFHQSxNQUFJLEtBQUssSUFBSSxDQUFiLEVBQWdCO0FBQ2YsV0FBTyxJQUFQO0FBQ0E7O0FBQ0QsSUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBTixLQUFhLEVBQUUsR0FBRyxFQUFsQixJQUF3QixDQUFDLEVBQUUsR0FBRyxFQUFOLEtBQWEsRUFBRSxHQUFHLEVBQWxCLENBQXpCLElBQWtELEtBQXZEO0FBQ0EsSUFBRSxHQUFHLENBQUMsQ0FBQyxFQUFFLEdBQUcsRUFBTixLQUFhLEVBQUUsR0FBRyxFQUFsQixJQUF3QixDQUFDLEVBQUUsR0FBRyxFQUFOLEtBQWEsRUFBRSxHQUFHLEVBQWxCLENBQXpCLElBQWtELEtBQXZEO0FBQ0EsU0FBTztBQUNOLEtBQUMsRUFBRSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFULENBREo7QUFFTixLQUFDLEVBQUUsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBVCxDQUZKO0FBR04sUUFBSSxFQUFFLEVBQUUsSUFBSSxDQUFOLElBQVcsRUFBRSxJQUFJLENBSGpCO0FBSU4sUUFBSSxFQUFFLEVBQUUsSUFBSSxDQUFOLElBQVcsRUFBRSxJQUFJO0FBSmpCLEdBQVA7QUFNQSxDOzs7Ozs7Ozs7Ozs7QUM1Q0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9XG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG4gXHRcdC8vIEZsYWcgdGhlIG1vZHVsZSBhcyBsb2FkZWRcbiBcdFx0bW9kdWxlLmwgPSB0cnVlO1xuXG4gXHRcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG4gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbiBcdH1cblxuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5tID0gbW9kdWxlcztcblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbiBcdF9fd2VicGFja19yZXF1aXJlX18uYyA9IGluc3RhbGxlZE1vZHVsZXM7XG5cbiBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gZnVuY3Rpb24oZXhwb3J0cywgbmFtZSwgZ2V0dGVyKSB7XG4gXHRcdGlmKCFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywgbmFtZSkpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbiBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcbiBcdFx0fVxuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4gXHQvLyBtb2RlICYgMTogdmFsdWUgaXMgYSBtb2R1bGUgaWQsIHJlcXVpcmUgaXRcbiBcdC8vIG1vZGUgJiAyOiBtZXJnZSBhbGwgcHJvcGVydGllcyBvZiB2YWx1ZSBpbnRvIHRoZSBuc1xuIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4gXHQvLyBtb2RlICYgOHwxOiBiZWhhdmUgbGlrZSByZXF1aXJlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbiBcdFx0aWYobW9kZSAmIDgpIHJldHVybiB2YWx1ZTtcbiBcdFx0aWYoKG1vZGUgJiA0KSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmIHZhbHVlICYmIHZhbHVlLl9fZXNNb2R1bGUpIHJldHVybiB2YWx1ZTtcbiBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yKG5zKTtcbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG5zLCAnZGVmYXVsdCcsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHZhbHVlIH0pO1xuIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4gXHRcdHJldHVybiBucztcbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cblxuIFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXG4gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2luZGV4LnRzXCIpO1xuIiwiaW1wb3J0IFNWR0dlb21ldHJ5Q29udHJvbGxlciBmcm9tICcuL1NWR0dlb21ldHJ5Q29udHJvbGxlcic7XHJcbmltcG9ydCB7IENvb3JkVHlwZSB9IGZyb20gJy4vY29tcHMvaW50ZXJmYWNlcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDaXJjbGVDb250cm9sbGVyIGV4dGVuZHMgU1ZHR2VvbWV0cnlDb250cm9sbGVyIHtcclxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdGNvbnN0cnVjdG9yKGVsZW1lbnQ/OiBTVkdFbGVtZW50LCB0eXBlOiBTVkdFbGVtZW50VHlwZXMgPSAnY2lyY2xlJykge1xyXG5cdFx0c3VwZXIoZWxlbWVudCwgdHlwZSk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgc2V0UmFkaXVzKHJhZGl1czogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnZhbGlkYXRlT3JJbnNlcnRGaXJzdENvb3JkWmVyb1plcm8oKTtcclxuXHRcdHRoaXMuZ2V0Q29vcmRzUmVmKClbMV0gPSB7IHR5cGU6IENvb3JkVHlwZS5TY2FsYXIsIHg6IHJhZGl1cyB9O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgbW92ZVRvKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XHJcblx0XHR0aGlzLmdldENvb3Jkc1JlZigpWzBdID0geyB4LCB5LCB0eXBlOiBDb29yZFR5cGUuTGluZWFyIH07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0IFNWR0dlb21ldHJ5Q29udHJvbGxlciBmcm9tICcuL1NWR0dlb21ldHJ5Q29udHJvbGxlcic7XHJcbmltcG9ydCB7IENvb3JkVHlwZSB9IGZyb20gJy4vY29tcHMvaW50ZXJmYWNlcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbGxpcHNlQ29udHJvbGxlciBleHRlbmRzIFNWR0dlb21ldHJ5Q29udHJvbGxlciB7XHJcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHRjb25zdHJ1Y3RvcihlbGVtZW50PzogU1ZHRWxlbWVudCwgdHlwZTogU1ZHRWxlbWVudFR5cGVzID0gJ2VsbGlwc2UnKSB7XHJcblx0XHRzdXBlcihlbGVtZW50LCB0eXBlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXRSYWRpdXMocmFkaXVzWDogbnVtYmVyLCByYWRpdXNZOiBudW1iZXIpIHtcclxuXHRcdHRoaXMudmFsaWRhdGVPckluc2VydEZpcnN0Q29vcmRaZXJvWmVybygpO1xyXG5cdFx0dGhpcy5nZXRDb29yZHNSZWYoKVsxXSA9IHsgdHlwZTogQ29vcmRUeXBlLkxpbmVhciwgeDogcmFkaXVzWCwgeTogcmFkaXVzWSB9O1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCBTVkdHZW9tZXRyeUNvbnRyb2xsZXIgZnJvbSAnLi9TVkdHZW9tZXRyeUNvbnRyb2xsZXInO1xyXG5pbXBvcnQgeyBDb29yZCwgQ29vcmRUeXBlLCBsaW5lVG9BYmxlLCBoYXNTZWdtZW50c0Rlc2NyaXB0b3IsIFBvaW50IH0gZnJvbSAnLi9jb21wcy9pbnRlcmZhY2VzJztcclxuaW1wb3J0IFNlZ21lbnRzRGVzY3JpcHRvciBmcm9tICcuL2NvbXBzL2Rlc2NyaXB0b3JzL1NlZ21lbnRzRGVzY3JpcHRvcic7XHJcbmltcG9ydCB7IFJlbmRlck1pZGRsZXdhcmUgfSBmcm9tICcuL2NvbXBzL21pZGRlbHdhcmVzL3JlbmRlci1taWRkbGV3YXJlcy9pbnRlcmZhY2VzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExpbmVDb250b2xsZXJcclxuXHRleHRlbmRzIFNWR0dlb21ldHJ5Q29udHJvbGxlclxyXG5cdGltcGxlbWVudHMgbGluZVRvQWJsZSwgaGFzU2VnbWVudHNEZXNjcmlwdG9yIHtcclxuXHRwcml2YXRlIF9zZWdtZW50c0Rlc2NyaXB0b3I6IFNlZ21lbnRzRGVzY3JpcHRvcjtcclxuXHRwcml2YXRlIF9yZW5kZXJNaWRkbGV3YXJlczogUmVuZGVyTWlkZGxld2FyZVtdID0gW107XHJcblxyXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0Y29uc3RydWN0b3IoZWxlbWVudD86IFNWR0VsZW1lbnQsIHR5cGU6IFNWR0VsZW1lbnRUeXBlcyA9ICdsaW5lJykge1xyXG5cdFx0c3VwZXIoZWxlbWVudCwgdHlwZSk7XHJcblx0XHR0aGlzLl9zZWdtZW50c0Rlc2NyaXB0b3IgPSBuZXcgU2VnbWVudHNEZXNjcmlwdG9yKHR5cGUpO1xyXG5cdH1cclxuXHRwdWJsaWMgZ2V0IHNlZ21lbnRzRGVzY3JpcHRvcigpOiBTZWdtZW50c0Rlc2NyaXB0b3Ige1xyXG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzRGVzY3JpcHRvcjtcclxuXHR9XHJcblxyXG5cdC8qKlxyXG5cdCAqIERyYXdzIGEgc3RyaWdodCBsaW5lIGZyb20gbGF0ZXN0IHBvaW50IHRvIHRhcmdldCB4LCB5XHJcblx0ICogQHBhcmFtIHhcclxuXHQgKiBAcGFyYW0geVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBsaW5lVG8oeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuXHRcdGNvbnN0IGNvb3JkOiBDb29yZCA9IHsgdHlwZTogQ29vcmRUeXBlLkxpbmVhciwgeCwgeSB9O1xyXG5cdFx0dGhpcy5hcHBlbmRDb29yZChjb29yZCk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXQgc2VnbWVudExlbmd0aHMoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNEZXNjcmlwdG9yLnNlZ21lbnRMZW5ndGhzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldCB0b3RhbExlbmd0aCgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50c0Rlc2NyaXB0b3IudG90YWxMZW5ndGg7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBDYWxjdWxhdGUgZ2VvbWV0cnkgZGF0YSBsaWtlIHRvdGFsIG91dGxpbmUgbGVuZ3RoLCBzZWdtZW50cyBsZW5ndGgsIGNlbnRlciBwb2ludCwgcmVkdWNlIHNoYXBlIHRvIHNpbXBsZSBzdHJpZ2h0IGxpbmVzIChpbXBvcnRhbnQgdG8gcGF0aHMpXHJcblx0ICovXHJcblx0cHVibGljIGNhbGN1bGF0ZSgpIHtcclxuXHRcdHRoaXMuX3NlZ21lbnRzRGVzY3JpcHRvci5jYWxjdWxhdGUodGhpcy5nZXRDb29yZHNSZWYoKSk7XHJcblx0XHRyZXR1cm4gc3VwZXIuY2FsY3VsYXRlKCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0QXR0cmlidXRlc0ZvckVsZW1lbnQoKSB7XHJcblx0XHRjb25zdCByZWR1Y2VSZW5kZXJNaWRkbGV3YXJlQ29vcmRzVXBkYXRlID0gKFxyXG5cdFx0XHRhY2M6IENvb3JkW10sXHJcblx0XHRcdG1pZGRsZXdhcmU6IFJlbmRlck1pZGRsZXdhcmVcclxuXHRcdCk6IENvb3JkW10gPT4ge1xyXG5cdFx0XHRyZXR1cm4gbWlkZGxld2FyZS5hY3RpdmUgPyBtaWRkbGV3YXJlLnVwZGF0ZUNvb3JkcyhhY2MpIDogYWNjO1xyXG5cdFx0fTtcclxuXHJcblx0XHRjb25zdCBjb29yZHM6IENvb3JkW10gPSB0aGlzLl9yZW5kZXJNaWRkbGV3YXJlcy5yZWR1Y2UocmVkdWNlUmVuZGVyTWlkZGxld2FyZUNvb3Jkc1VwZGF0ZSwgW1xyXG5cdFx0XHQuLi50aGlzLmdldENvb3Jkc1JlZigpLFxyXG5cdFx0XSk7XHJcblx0XHRyZXR1cm4gdGhpcy5jb29yZGluYXRlc1BhcnNlci5jcmVhdGVFbGVtZW50QXR0cnMoY29vcmRzKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRCb3JkZXJJbnRlcnNlY3Rpb24ocDE6IFBvaW50LCBzaGFwZUFuY2hvcj86IFBvaW50KSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNEZXNjcmlwdG9yLmdldEJvcmRlckludGVyc2VjdGlvbih0aGlzLmdldENvb3Jkc1JlZigpLCBwMSwgc2hhcGVBbmNob3IpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGFkZFJlbmRlck1pZGRsZXdhcmUobWlkZGxld2FyZTogUmVuZGVyTWlkZGxld2FyZSkge1xyXG5cdFx0dGhpcy5fcmVuZGVyTWlkZGxld2FyZXMucHVzaChtaWRkbGV3YXJlKTtcclxuXHRcdG1pZGRsZXdhcmUuc2V0Q29udHJvbGxlcih0aGlzKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyByZW1vdmVSZW5kZXJNaWRkbGV3YXJlKG1pZGRsZXdhcmU6IFJlbmRlck1pZGRsZXdhcmUpIHtcclxuXHRcdG1pZGRsZXdhcmUudW5zZXRDb250cm9sbGVyKCk7XHJcblx0XHRjb25zdCBpID0gdGhpcy5fcmVuZGVyTWlkZGxld2FyZXMuaW5kZXhPZihtaWRkbGV3YXJlKTtcclxuXHRcdGlmIChpID4gLTEpIHtcclxuXHRcdFx0dGhpcy5fcmVuZGVyTWlkZGxld2FyZXMuc3BsaWNlKGksIDEpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldCBoYXNSZWRuZXJNaWRkbGV3YXJlcygpIHtcclxuXHRcdHJldHVybiB0aGlzLl9yZW5kZXJNaWRkbGV3YXJlcy5sZW5ndGggPiAwO1xyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQgeyBhbGxWYWx1ZXNBc3NpZ25lZCB9IGZyb20gJy4uL2hlbHBlcnMvaW5wdXRfdmFsaWRhdGlvbnMnO1xyXG5pbXBvcnQgUG9seWxpbmVDb250cm9sbGVyIGZyb20gJy4vUG9seWxpbmVDb250cm9sbGVyJztcclxuaW1wb3J0IHsgQ29vcmRUeXBlLCBDdWJpY0JlemllckNvb3JkLCBRdWFkcmF0aWNCZXppZXJDb29yZCB9IGZyb20gJy4vY29tcHMvaW50ZXJmYWNlcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQYXRoQ29udHJvbGxlciBleHRlbmRzIFBvbHlsaW5lQ29udHJvbGxlciB7XHJcblx0Ly9wcml2YXRlIF9pbnN0cnVjdGlvbnM6IHN0cmluZ09yTnVtYmVyW107XHJcblxyXG5cdGNvbnN0cnVjdG9yKFxyXG5cdFx0ZWxlbWVudD86IFNWR0VsZW1lbnQsXHJcblx0XHQvL2luc3RydWN0aW9uczogc3RyaW5nT3JOdW1iZXJbXSA9IFtdLFxyXG5cdFx0dHlwZTogU1ZHRWxlbWVudFR5cGVzID0gJ3BhdGgnXHJcblx0KSB7XHJcblx0XHRzdXBlcihlbGVtZW50LCB0eXBlKTtcclxuXHRcdC8vdGhpcy5faW5zdHJ1Y3Rpb25zID0gaW5zdHJ1Y3Rpb25zO1xyXG5cdFx0dGhpcy5lbGVtZW50ID0gZWxlbWVudDtcclxuXHR9XHJcblx0LypcclxuXHRwdWJsaWMgZ2V0SW5zdHJ1Y3Rpb25zKCk6IHN0cmluZ09yTnVtYmVyW10ge1xyXG5cdFx0cmV0dXJuIFsuLi50aGlzLl9pbnN0cnVjdGlvbnNdO1xyXG5cdH1cclxuKi9cclxuXHRwdWJsaWMgZ2V0QXR0cmlidXRlc0ZvckVsZW1lbnQoKSB7XHJcblx0XHRpZiAodGhpcy5oYXNSZWRuZXJNaWRkbGV3YXJlcykge1xyXG5cdFx0XHRyZXR1cm4gc3VwZXIuZ2V0QXR0cmlidXRlc0ZvckVsZW1lbnQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzLmNvb3JkaW5hdGVzUGFyc2VyLmNyZWF0ZUVsZW1lbnRBdHRycyh0aGlzLmdldENvb3Jkc1JlZigpKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjbGVhcih1cGRhdGVFbGVtZW50ID0gZmFsc2UpIHtcclxuXHRcdC8vdGhpcy5faW5zdHJ1Y3Rpb25zLmxlbmd0aCA9IDA7XHJcblx0XHRyZXR1cm4gc3VwZXIuY2xlYXIodXBkYXRlRWxlbWVudCk7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgY2xvc2VQYXRoKCkge1xyXG5cdFx0Y29uc3QgZmlyc3RDb29yZCA9IHRoaXMuZ2V0Q29vcmRzUmVmKClbMF07XHJcblx0XHR0aGlzLmxpbmVUbyhmaXJzdENvb3JkLngsIGZpcnN0Q29vcmQueSEpO1xyXG5cdFx0Ly90aGlzLl9pbnN0cnVjdGlvbnMucHVzaCgneicpO1xyXG5cdFx0Ly8gVE9ETzogc2hvdWxkIGJlIHBhcnQgb2YgdGhlIHNlZ21lbnRzIGFuZCB0b3RhbCBsZW5ndGggaW4gdGhlIHNlZ21lbnQgZGVzYy4uLiBtYWtlIHN1cmUgaXQgaXMgd29ya2luZ1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgdW5jbG9zZSgpIHtcclxuXHRcdC8vIFRPRE86IHVuaXQgdGVzdCB1bmNsb3NlXHJcblx0XHRpZiAodGhpcy5pc0Nsb3NlZCkge1xyXG5cdFx0XHR0aGlzLmdldENvb3Jkc1JlZigpLnBvcCgpO1xyXG5cdFx0fVxyXG5cdH1cclxuXHJcblx0cHVibGljIGdldCBpc0Nsb3NlZCgpIHtcclxuXHRcdC8vcmV0dXJuIHRoaXMuX2luc3RydWN0aW9uc1t0aGlzLl9pbnN0cnVjdGlvbnMubGVuZ3RoIC0gMV0gPT09ICd6JztcclxuXHRcdGNvbnN0IGNvb3JkcyA9IHRoaXMuZ2V0Q29vcmRzUmVmKCk7XHJcblx0XHRjb25zdCBsYXN0Q29vcmQgPSBjb29yZHNbY29vcmRzLmxlbmd0aCAtIDFdO1xyXG5cdFx0cmV0dXJuIGNvb3Jkc1swXS54ID09IGxhc3RDb29yZC54ICYmIGNvb3Jkc1swXS55ID09IGxhc3RDb29yZC55O1xyXG5cdH1cclxuXHJcblx0cHVibGljIG1vdmVUbyh4OiBudW1iZXIsIHk6IG51bWJlcikge1xyXG5cdFx0Ly90aGlzLl9pbnN0cnVjdGlvbnMucHVzaChgTSR7eH0sJHt5fWApO1xyXG5cdFx0c3VwZXIubW92ZVRvKHgsIHkpO1xyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgbGluZVRvKHg6IG51bWJlciwgeTogbnVtYmVyKSB7XHJcblx0XHQvL3RoaXMuX2luc3RydWN0aW9ucy5wdXNoKGBMJHt4fSwke3l9YCk7XHJcblx0XHR0aGlzLnZhbGlkYXRlT3JJbnNlcnRGaXJzdENvb3JkWmVyb1plcm8oKTtcclxuXHRcdHN1cGVyLmxpbmVUbyh4LCB5KTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGN1YmljVG8gPSAoXHJcblx0XHRjdHJsWDogbnVtYmVyLFxyXG5cdFx0Y3RybFk6IG51bWJlcixcclxuXHRcdGN0cmxYMjogbnVtYmVyLFxyXG5cdFx0Y3RybFkyOiBudW1iZXIsXHJcblx0XHRlbmRYOiBudW1iZXIsXHJcblx0XHRlbmRZOiBudW1iZXIsXHJcblx0XHRtaXJyb3JFbmRYPzogbnVtYmVyLFxyXG5cdFx0bWlycm9yRW5kWT86IG51bWJlclxyXG5cdCkgPT4ge1xyXG5cdFx0Ly8gYWRkIG1pcnJvciBTXHJcblxyXG5cdFx0Ly90aGlzLl9pbnN0cnVjdGlvbnMucHVzaChgQyR7Y3RybFh9LCR7Y3RybFl9LCR7Y3RybFgyfSwke2N0cmxZMn0sJHtlbmRYfSwke2VuZFl9YCk7XHJcblxyXG5cdFx0aWYgKGFsbFZhbHVlc0Fzc2lnbmVkKG1pcnJvckVuZFgsIG1pcnJvckVuZFkpKSB7XHJcblx0XHRcdHRocm93ICdiZXppZXJDdWJpYyB3aXRoIG1pcnJvciBub3QgaW1wbGVtZW50ZWQnO1xyXG5cdFx0XHQvL3RoaXMuX2luc3RydWN0aW9ucy5wdXNoKGBTJHttaXJyb3JFbmRYfSwke21pcnJvckVuZFl9YCk7XHJcblx0XHR9XHJcblxyXG5cdFx0Y29uc3QgY29vcmQ6IEN1YmljQmV6aWVyQ29vcmQgPSB7XHJcblx0XHRcdHR5cGU6IENvb3JkVHlwZS5CZXppZXJDdWJpYyxcclxuXHRcdFx0eDogZW5kWCxcclxuXHRcdFx0eTogZW5kWSxcclxuXHRcdFx0Y3RybFgsXHJcblx0XHRcdGN0cmxZLFxyXG5cdFx0XHRjdHJsWDIsXHJcblx0XHRcdGN0cmxZMixcclxuXHRcdH07XHJcblx0XHR0aGlzLmFwcGVuZENvb3JkKGNvb3JkKTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH07XHJcblxyXG5cdHB1YmxpYyBxdWFkVG8gPSAoXHJcblx0XHRjdHJsWDogbnVtYmVyLFxyXG5cdFx0Y3RybFk6IG51bWJlcixcclxuXHRcdGVuZFg6IG51bWJlcixcclxuXHRcdGVuZFk6IG51bWJlcixcclxuXHRcdG1pcnJvckVuZFg/OiBudW1iZXIsXHJcblx0XHRtaXJyb3JFbmRZPzogbnVtYmVyXHJcblx0KSA9PiB7XHJcblx0XHQvL3RoaXMuX2luc3RydWN0aW9ucy5wdXNoKGBRJHtjdHJsWH0sJHtjdHJsWX0sJHtlbmRYfSwke2VuZFl9YCk7XHJcblx0XHRjb25zdCBpc01pcnJvciA9IGFsbFZhbHVlc0Fzc2lnbmVkKG1pcnJvckVuZFgsIG1pcnJvckVuZFkpO1xyXG5cdFx0aWYgKGlzTWlycm9yKSB7XHJcblx0XHRcdHRocm93ICdiZXppZXJDdWJpYyB3aXRoIG1pcnJvciBub3QgaW1wbGVtZW50ZWQnO1xyXG5cdFx0XHQvL3RoaXMuX2luc3RydWN0aW9ucy5wdXNoKGBUJHttaXJyb3JFbmRYfSwke21pcnJvckVuZFl9YCk7XHJcblx0XHR9XHJcblx0XHRjb25zdCBjb29yZDogUXVhZHJhdGljQmV6aWVyQ29vcmQgPSB7XHJcblx0XHRcdHR5cGU6IGlzTWlycm9yID8gQ29vcmRUeXBlLkJlemllck1pcnJvciA6IENvb3JkVHlwZS5CZXppZXJRdWFkcmF0aWMsXHJcblx0XHRcdHg6IGVuZFgsXHJcblx0XHRcdHk6IGVuZFksXHJcblx0XHRcdGN0cmxYLFxyXG5cdFx0XHRjdHJsWSxcclxuXHRcdFx0bWlycm9yWDogbWlycm9yRW5kWCxcclxuXHRcdFx0bWlycm9yWTogbWlycm9yRW5kWSxcclxuXHRcdH07XHJcblx0XHR0aGlzLmFwcGVuZENvb3JkKGNvb3JkKTtcclxuXHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9O1xyXG59XHJcbiIsImltcG9ydCBQb2x5bGluZUNvbnRyb2xsZXIgZnJvbSAnLi9Qb2x5bGluZUNvbnRyb2xsZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWdvbkNvbnRyb2xsZXIgZXh0ZW5kcyBQb2x5bGluZUNvbnRyb2xsZXIge1xyXG5cdC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXHJcblx0Y29uc3RydWN0b3IoZWxlbWVudD86IFNWR0VsZW1lbnQsIHR5cGU6IFNWR0VsZW1lbnRUeXBlcyA9ICdwb2x5Z29uJykge1xyXG5cdFx0c3VwZXIoZWxlbWVudCwgdHlwZSk7XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCBMaW5lQ29udG9sbGVyIGZyb20gJy4vTGluZUNvbnRyb2xsZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUG9seWxpbmVDb250cm9sbGVyIGV4dGVuZHMgTGluZUNvbnRvbGxlciB7XHJcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHRjb25zdHJ1Y3RvcihlbGVtZW50PzogU1ZHRWxlbWVudCwgdHlwZTogU1ZHRWxlbWVudFR5cGVzID0gJ3BvbHlsaW5lJykge1xyXG5cdFx0c3VwZXIoZWxlbWVudCwgdHlwZSk7XHJcblx0fVxyXG59XHJcbiIsImltcG9ydCB7IHZhbHVlQXNzaWduZWQgfSBmcm9tICcuLi9oZWxwZXJzL2lucHV0X3ZhbGlkYXRpb25zJztcclxuaW1wb3J0IFNWR0dlb21ldHJ5Q29udHJvbGxlciBmcm9tICcuL1NWR0dlb21ldHJ5Q29udHJvbGxlcic7XHJcbmltcG9ydCB7IENvb3JkVHlwZSB9IGZyb20gJy4vY29tcHMvaW50ZXJmYWNlcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSZWN0Q29udHJvbGxlciBleHRlbmRzIFNWR0dlb21ldHJ5Q29udHJvbGxlciB7XHJcblx0LyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuXHRjb25zdHJ1Y3RvcihlbGVtZW50PzogU1ZHRWxlbWVudCwgdHlwZTogU1ZHRWxlbWVudFR5cGVzID0gJ3JlY3QnKSB7XHJcblx0XHRzdXBlcihlbGVtZW50LCB0eXBlKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBzZXREaW1lbnNpb25zKHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyKSB7XHJcblx0XHR0aGlzLnZhbGlkYXRlT3JJbnNlcnRGaXJzdENvb3JkWmVyb1plcm8oKTtcclxuXHRcdHRoaXMuZ2V0Q29vcmRzUmVmKClbMV0gPSB7IHR5cGU6IENvb3JkVHlwZS5MaW5lYXIsIHg6IHdpZHRoLCB5OiBoZWlnaHQgfTtcclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHNldENvcm5lclJhZGl1cyh4OiBudW1iZXIsIHk/OiBudW1iZXIpIHtcclxuXHRcdHRoaXMuZ2V0Q29vcmRzUmVmKClbMl0gPSB7XHJcblx0XHRcdHR5cGU6IENvb3JkVHlwZS5MaW5lYXIsXHJcblx0XHRcdHgsXHJcblx0XHRcdHk6IHZhbHVlQXNzaWduZWQoeSkgPyB5IDogeCxcclxuXHRcdH07XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0IHsgQ29vcmQsIENvb3JkVHlwZSB9IGZyb20gJy4vY29tcHMvaW50ZXJmYWNlcyc7XHJcbmltcG9ydCB7IENvb3Jkc1RvRWxlbUF0dHJzLCBDb29yZHNUb0VsZW1BdHRyc01hcCB9IGZyb20gJy4vY29tcHMvY29vcmRpbmF0ZXMvQ29vcmRzVG9FbGVtQXR0cnMnO1xyXG5cclxubGV0IGlkQ291bnRlciA9IDA7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBTVkdHZW9tZXRyeUNvbnRyb2xsZXIge1xyXG5cdHByaXZhdGUgX2lkOiBudW1iZXI7XHJcblx0cHJpdmF0ZSBfdHlwZTogU1ZHRWxlbWVudFR5cGVzO1xyXG5cclxuXHRwcm90ZWN0ZWQgZWxlbWVudDogU1ZHRWxlbWVudCB8IHVuZGVmaW5lZDtcclxuXHRwcml2YXRlIF9jb29yZHM6IENvb3JkW10gPSBbXTtcclxuXHJcblx0cHJpdmF0ZSBfY29vcmRpbmF0ZXNQYXJzZXI6IENvb3Jkc1RvRWxlbUF0dHJzO1xyXG5cclxuXHRjb25zdHJ1Y3RvcihlbGVtZW50PzogU1ZHRWxlbWVudCwgdHlwZTogU1ZHRWxlbWVudFR5cGVzID0gJ3N2ZycpIHtcclxuXHRcdHRoaXMuX2lkID0gKytpZENvdW50ZXI7XHJcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcclxuXHRcdHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XHJcblx0XHR0aGlzLl9jb29yZGluYXRlc1BhcnNlciA9IENvb3Jkc1RvRWxlbUF0dHJzTWFwW3R5cGVdO1xyXG5cdH1cclxuXHJcblx0Z2V0IGlkKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2lkO1xyXG5cdH1cclxuXHJcblx0Z2V0IHR5cGUoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcclxuXHR9XHJcblxyXG5cdGdldCBjb29yZGluYXRlc1BhcnNlcigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb29yZGluYXRlc1BhcnNlcjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRBdHRyaWJ1dGVzRm9yRWxlbWVudCgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb29yZGluYXRlc1BhcnNlci5jcmVhdGVFbGVtZW50QXR0cnModGhpcy5fY29vcmRzKTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyB1cGRhdGVFbGVtZW50KCkge1xyXG5cdFx0aWYgKHRoaXMuZWxlbWVudCkge1xyXG5cdFx0XHRjb25zdCBhdHRycyA9IHRoaXMuZ2V0QXR0cmlidXRlc0ZvckVsZW1lbnQoKTtcclxuXHRcdFx0T2JqZWN0LmVudHJpZXMoYXR0cnMpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG5cdFx0XHRcdHRoaXMuZWxlbWVudCEuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUgYXMgc3RyaW5nKTtcclxuXHRcdFx0fSk7XHJcblx0XHR9XHJcblxyXG5cdFx0cmV0dXJuIHRoaXM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0Q29vcmRzKCk6IENvb3JkW10ge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2Nvb3Jkcy5tYXAoY29vcmQgPT4gKHsgLi4uY29vcmQgfSkpO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIGdldENvb3Jkc1JlZigpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb29yZHM7XHJcblx0fVxyXG5cclxuXHQvKipcclxuXHQgKiBAZGVzY3JpcHRpb24gbXVzdCBiZSBjYWxsZWQgYWZ0ZXIgbWFuaXB1bGF0aW9uIChvciBhIHNlcmllcyBvZiBtYW5pcHVsYXRpb24pIG9mIHRoZSBzaGFwZSB0aGF0IG1heSBlZmZlY3Qgc2l6ZVxyXG5cdCAqL1xyXG5cdHB1YmxpYyBjYWxjdWxhdGUoKSB7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHByb3RlY3RlZCBhcHBlbmRDb29yZChjb29yZDogQ29vcmQsIGlzTW92ZVRvOiBib29sZWFuID0gZmFsc2UpIHtcclxuXHRcdGlmICghaXNNb3ZlVG8pIHtcclxuXHRcdFx0dGhpcy52YWxpZGF0ZU9ySW5zZXJ0Rmlyc3RDb29yZFplcm9aZXJvKCk7XHJcblx0XHR9XHJcblxyXG5cdFx0dGhpcy5fY29vcmRzLnB1c2goY29vcmQpO1xyXG5cdFx0dGhpcy5fY29vcmRpbmF0ZXNQYXJzZXIudmFsaWRhdGVDb29yZGluYXRlcyh0aGlzLl9jb29yZHMpO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGNsZWFyKHVwZGF0ZUVsZW1lbnQgPSBmYWxzZSkge1xyXG5cdFx0dGhpcy5fY29vcmRzLmxlbmd0aCA9IDA7XHJcblx0XHRpZiAodXBkYXRlRWxlbWVudCkge1xyXG5cdFx0XHR0aGlzLnVwZGF0ZUVsZW1lbnQoKTtcclxuXHRcdH1cclxuXHRcdHJldHVybiB0aGlzO1xyXG5cdH1cclxuXHJcblx0cHJvdGVjdGVkIHZhbGlkYXRlT3JJbnNlcnRGaXJzdENvb3JkWmVyb1plcm8oKSB7XHJcblx0XHR0aGlzLl9jb29yZHMubGVuZ3RoID09PSAwICYmIHRoaXMuX2Nvb3Jkcy5wdXNoKHsgdHlwZTogQ29vcmRUeXBlLkxpbmVhciwgeDogMCwgeTogMCB9KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBtb3ZlVG8oeDogbnVtYmVyLCB5OiBudW1iZXIpIHtcclxuXHRcdGNvbnN0IGNvb3JkOiBDb29yZCA9IHsgdHlwZTogQ29vcmRUeXBlLkxpbmVhciwgeCwgeSwgbW92ZTogdHJ1ZSB9O1xyXG5cdFx0dGhpcy5hcHBlbmRDb29yZChjb29yZCwgdHJ1ZSk7XHJcblx0XHRyZXR1cm4gdGhpcztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXRFbGVtZW50KCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuZWxlbWVudDtcclxuXHR9XHJcbn1cclxuIiwiaW1wb3J0IHsgY3JlYXRlUHJveHkgfSBmcm9tICdzcmMvaGVscGVycy9vYmplY3RfdXRpbHMnO1xyXG5pbXBvcnQgeyB2YWx1ZUFzc2lnbmVkIH0gZnJvbSAnc3JjL2hlbHBlcnMvaW5wdXRfdmFsaWRhdGlvbnMnO1xyXG5pbXBvcnQgeyBDb29yZCwgQ29vcmRUeXBlLCBDdWJpY0JlemllckNvb3JkLCBRdWFkcmF0aWNCZXppZXJDb29yZCB9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvb3Jkc1RvRWxlbUF0dHJzIHtcclxuXHRwdWJsaWMgYWJzdHJhY3QgdmFsaWRhdGVDb29yZGluYXRlcyhjb29yZHM6IENvb3JkW10pOiBib29sZWFuO1xyXG5cdHB1YmxpYyBhYnN0cmFjdCBjcmVhdGVFbGVtZW50QXR0cnMoY29vcmRzOiBDb29yZFtdKTogYW55O1xyXG59XHJcblxyXG5jbGFzcyBTdHJpY3RPcmRlclByb3BzIGV4dGVuZHMgQ29vcmRzVG9FbGVtQXR0cnMge1xyXG5cdHByaXZhdGUgb3JkZXJlZFByb3BzOiBzdHJpbmdbXTtcclxuXHJcblx0Y29uc3RydWN0b3Iob3JkZXJlZFByb3BzOiBzdHJpbmdbXSkge1xyXG5cdFx0c3VwZXIoKTtcclxuXHRcdHRoaXMub3JkZXJlZFByb3BzID0gb3JkZXJlZFByb3BzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIHZhbGlkYXRlQ29vcmRpbmF0ZXMoY29vcmRzOiBDb29yZFtdKTogYm9vbGVhbiB7XHJcblx0XHRjb25zdCBjb29yZHNDb3VudCA9IHRoaXMub3JkZXJlZFByb3BzLmxlbmd0aCAvIDI7XHJcblx0XHRpZiAoY29vcmRzQ291bnQgPT09IE1hdGgucm91bmQoY29vcmRzQ291bnQpKSB7XHJcblx0XHRcdHJldHVybiBjb29yZHMubGVuZ3RoID09PSBjb29yZHNDb3VudDtcclxuXHRcdH1cclxuXHJcblx0XHQvLyB2YWxpZGF0ZSB3aGVuIGxhc3QgY29vcmQgc2hvdWxkIG5vdCBoYXZlIHNlY29uZHMgdmFsdWUgKCd5JyBtZW1iZXIgc2hvdWxkIGJlIHVuZGVmaW5lZClcclxuXHRcdHJldHVybiAoXHJcblx0XHRcdGNvb3Jkcy5sZW5ndGggPT09IE1hdGguY2VpbChjb29yZHNDb3VudCkgJiYgIXZhbHVlQXNzaWduZWQoY29vcmRzW2Nvb3Jkcy5sZW5ndGggLSAxXS55KVxyXG5cdFx0KTtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBjcmVhdGVFbGVtZW50QXR0cnMoY29vcmRzOiBDb29yZFtdKTogYW55IHtcclxuXHRcdGNvbnN0IGF0dHJzOiBhbnkgPSB7fTtcclxuXHRcdGxldCBwcm9wSW5kZXg6IG51bWJlciA9IDA7XHJcblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xyXG5cdFx0XHRjb25zdCBjb29yZCA9IGNvb3Jkc1tpXTtcclxuXHRcdFx0YXR0cnNbdGhpcy5vcmRlcmVkUHJvcHNbcHJvcEluZGV4XV0gPSBjb29yZC54O1xyXG5cdFx0XHRpZiAoY29vcmQudHlwZSAhPT0gQ29vcmRUeXBlLlNjYWxhciAmJiBwcm9wSW5kZXggKyAxIDwgdGhpcy5vcmRlcmVkUHJvcHMubGVuZ3RoKSB7XHJcblx0XHRcdFx0YXR0cnNbdGhpcy5vcmRlcmVkUHJvcHNbKytwcm9wSW5kZXhdXSA9IGNvb3JkLnk7XHJcblx0XHRcdH1cclxuXHRcdFx0Kytwcm9wSW5kZXg7XHJcblx0XHR9XHJcblx0XHRyZXR1cm4gYXR0cnM7XHJcblx0fVxyXG59XHJcblxyXG5jbGFzcyBVbmxpbWl0ZWRQb2ludHMgZXh0ZW5kcyBDb29yZHNUb0VsZW1BdHRycyB7XHJcblx0Y29uc3RydWN0b3IoKSB7XHJcblx0XHRzdXBlcigpO1xyXG5cdH1cclxuXHRwdWJsaWMgdmFsaWRhdGVDb29yZGluYXRlcygpOiBib29sZWFuIHtcclxuXHRcdHJldHVybiB0cnVlO1xyXG5cdH1cclxuXHRwdWJsaWMgY3JlYXRlRWxlbWVudEF0dHJzKGNvb3JkczogQ29vcmRbXSk6IGFueSB7XHJcblx0XHRyZXR1cm4gY29vcmRzLnJlZHVjZShcclxuXHRcdFx0KGFjYzogYW55LCBjb29yZCkgPT4ge1xyXG5cdFx0XHRcdGFjYy5wb2ludHMucHVzaChjb29yZC54KTtcclxuXHRcdFx0XHRhY2MucG9pbnRzLnB1c2goY29vcmQueSk7XHJcblx0XHRcdFx0cmV0dXJuIGFjYztcclxuXHRcdFx0fSxcclxuXHRcdFx0eyBwb2ludHM6IFtdIH1cclxuXHRcdCk7XHJcblx0fVxyXG59XHJcblxyXG5jb25zdCB1bmxpbWl0ZWRQb2ludHMgPSBuZXcgVW5saW1pdGVkUG9pbnRzKCk7XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKiBQYXRoIGluc3RydWN0aW9ucyAqKioqKioqKioqKioqKioqKioqKioqKlxyXG5jb25zdCBjb29yZFRvUGF0aEluc3RydWN0aW9ucyA9IGNyZWF0ZVByb3h5KFxyXG5cdHtcclxuXHRcdExJTkVBUjogKHsgeCwgeSwgbW92ZSB9OiBDb29yZCkgPT4gYCR7bW92ZSA/ICdNJyA6ICdMJ30ke3h9LCR7eX1gLFxyXG5cdFx0QkVaSUVSX1FVQURSQVRJQzogKHsgY3RybFksIGN0cmxYLCB4LCB5IH06IFF1YWRyYXRpY0JlemllckNvb3JkKSA9PlxyXG5cdFx0XHRgUSR7Y3RybFh9LCR7Y3RybFl9LCR7eH0sJHt5fWAsXHJcblx0XHRCRVpJRVJfQ1VCSUM6ICh7IGN0cmxZLCBjdHJsWCwgY3RybFgyLCBjdHJsWTIsIHgsIHkgfTogQ3ViaWNCZXppZXJDb29yZCkgPT5cclxuXHRcdFx0YEMke2N0cmxYfSwke2N0cmxZfSwke2N0cmxYMn0sJHtjdHJsWTJ9LCR7eH0sJHt5fWAsXHJcblx0fSxcclxuXHQoY29vcmQ6IENvb3JkKSA9PiB7XHJcblx0XHR0aHJvdyBgY29vcmRUb1BhdGhJbnN0cnVjdGlvbnMgY2FuJ3QgaGFuZGxlIGNvb3JkIG9mIHR5cGUgJHtjb29yZC50eXBlfWA7XHJcblx0fVxyXG4pO1xyXG5cclxuY2xhc3MgUGF0aENvb3JkaWFudGVzUGFyc2VyIGV4dGVuZHMgQ29vcmRzVG9FbGVtQXR0cnMge1xyXG5cdGNvbnN0cnVjdG9yKCkge1xyXG5cdFx0c3VwZXIoKTtcclxuXHR9XHJcblx0cHVibGljIHZhbGlkYXRlQ29vcmRpbmF0ZXMoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gdHJ1ZTtcclxuXHR9XHJcblx0cHVibGljIGNyZWF0ZUVsZW1lbnRBdHRycyhjb29yZHM6IENvb3JkW10pOiBhbnkge1xyXG5cdFx0Y29uc3QgZmlyc3Q6IENvb3JkID0gY29vcmRzWzBdO1xyXG5cdFx0cmV0dXJuIHtcclxuXHRcdFx0ZDogY29vcmRzXHJcblx0XHRcdFx0Lm1hcCgoYywgaW5kZXgpID0+IHtcclxuXHRcdFx0XHRcdGlmIChcclxuXHRcdFx0XHRcdFx0aW5kZXggPT09IGNvb3Jkcy5sZW5ndGggLSAxICYmXHJcblx0XHRcdFx0XHRcdGMudHlwZSA9PT0gQ29vcmRUeXBlLkxpbmVhciAmJlxyXG5cdFx0XHRcdFx0XHRjLnggPT09IGZpcnN0LnggJiZcclxuXHRcdFx0XHRcdFx0Yy55ID09PSBmaXJzdC55XHJcblx0XHRcdFx0XHQpIHtcclxuXHRcdFx0XHRcdFx0Ly8gaXMgY2xvc2VcclxuXHRcdFx0XHRcdFx0cmV0dXJuICd6JztcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHRcdHJldHVybiBjb29yZFRvUGF0aEluc3RydWN0aW9uc1tjLnR5cGVdKGMpO1xyXG5cdFx0XHRcdH0pXHJcblx0XHRcdFx0LmpvaW4oJyAnKSxcclxuXHRcdH07XHJcblx0fVxyXG59XHJcblxyXG4vLyAqKioqKioqKioqKioqKioqKioqKioqKiBDb29yZHNUb0VsZW1BdHRyc01hcCAqKioqKioqKioqKioqKioqKioqKioqKlxyXG5leHBvcnQgY29uc3QgQ29vcmRzVG9FbGVtQXR0cnNNYXAgPSBjcmVhdGVQcm94eTxDb29yZHNUb0VsZW1BdHRycz4oe1xyXG5cdGNpcmNsZTogbmV3IFN0cmljdE9yZGVyUHJvcHMoWydjeCcsICdjeScsICdyJ10pLFxyXG5cdGVsbGlwc2U6IG5ldyBTdHJpY3RPcmRlclByb3BzKFsnY3gnLCAnY3knLCAncngnLCAncnknXSksXHJcblx0bGluZTogbmV3IFN0cmljdE9yZGVyUHJvcHMoWyd4MScsICd5MScsICd4MicsICd5MiddKSxcclxuXHRwYXRoOiBuZXcgUGF0aENvb3JkaWFudGVzUGFyc2VyKCksXHJcblx0cG9seWdvbjogdW5saW1pdGVkUG9pbnRzLFxyXG5cdHBvbHlsaW5lOiB1bmxpbWl0ZWRQb2ludHMsXHJcblx0cmVjdDogbmV3IFN0cmljdE9yZGVyUHJvcHMoWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0JywgJ3J4JywgJ3J5J10pLFxyXG59KTtcclxuIiwiaW1wb3J0IHsgQ29vcmQsIENvb3JkVHlwZSwgUG9pbnQgfSBmcm9tICcuLi9pbnRlcmZhY2VzJztcclxuaW1wb3J0IHsgY29vcmRMZW5ndGhDYWxjdWxhdG9ycywgZ2V0UG9pbnRzT2ZDb29yZCB9IGZyb20gJy4uL3V0aWxzL2Jlemllcl91dGlscyc7XHJcbmltcG9ydCB7IHZhbHVlQXNzaWduZWQgfSBmcm9tICdzcmMvaGVscGVycy9pbnB1dF92YWxpZGF0aW9ucyc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIFNpbXBsZmllZCB7XHJcblx0Ly8gYXJyYXkgb2YgeCwgeSwgeCwgeS4uLlxyXG5cdGNvb3Jkcz86IG51bWJlcltdO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTZWdtZW50c0Rlc2NyaXB0b3Ige1xyXG5cdHByaXZhdGUgX2Nvb3JkczogQ29vcmRbXSA9IFtdO1xyXG5cdHByaXZhdGUgX3N2Z0VsZW1UeXBlOiBTVkdFbGVtZW50VHlwZXM7XHJcblx0cHJpdmF0ZSBfc2VnbWVudExlbmd0aHM6IG51bWJlcltdID0gW107XHJcblx0cHJpdmF0ZSBfc2VnbWVudEFjY3VtdWxhdGVkTGVuZ3RoczogbnVtYmVyW10gPSBbXTtcclxuXHJcblx0Ly8gdGhlIGNvdW50IG9mIHNpbXBsaWZpZWQgY29vcmRzIG9yaWdpbmFsIGNvb3JkIGhhc1xyXG5cdHByaXZhdGUgX3NlZ21lbnRUb1NpbXBsaWZpZWRSYW5nZTogbnVtYmVyW10gPSBbXTtcclxuXHRwcml2YXRlIF90b3RhbExlbmd0aDogbnVtYmVyID0gMDtcclxuXHRwcml2YXRlIF9jZW50ZXI6IFBvaW50IHwgdW5kZWZpbmVkO1xyXG5cdHByaXZhdGUgX2xhc3RDb29yZEVuZHNBdEZpcnN0OiBib29sZWFuID0gZmFsc2U7XHJcblxyXG5cdHByaXZhdGUgX3NpbXBsZmllZDogU2ltcGxmaWVkID0ge307XHJcblxyXG5cdGNvbnN0cnVjdG9yKGVsZW1lbnRUeXBlOiBTVkdFbGVtZW50VHlwZXMpIHtcclxuXHRcdHRoaXMuX3N2Z0VsZW1UeXBlID0gZWxlbWVudFR5cGU7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0IGNhbGN1bGF0ZWQoKTogYm9vbGVhbiB7XHJcblx0XHRyZXR1cm4gISF0aGlzLl9jZW50ZXI7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0IGNvb3JkcygpIHtcclxuXHRcdHJldHVybiB0aGlzLl9jb29yZHM7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0IHN2Z0VsZW1UeXBlKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX3N2Z0VsZW1UeXBlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldCBzZWdtZW50TGVuZ3RocygpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50TGVuZ3RocztcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXQgc2VnbWVudEFjY3VtdWxhdGVkTGVuZ3RocygpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50QWNjdW11bGF0ZWRMZW5ndGhzO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldCBzZWdtZW50VG9TaW1wbGlmaWVkUmFuZ2UoKSB7XHJcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudFRvU2ltcGxpZmllZFJhbmdlO1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldCB0b3RhbExlbmd0aCgpIHtcclxuXHRcdHJldHVybiB0aGlzLl90b3RhbExlbmd0aDtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXQgY2VudGVyKCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2NlbnRlcjtcclxuXHR9XHJcblxyXG5cdHB1YmxpYyBnZXQgc2ltcGlsZmllZCgpIHtcclxuXHRcdHJldHVybiB0aGlzLl9zaW1wbGZpZWQ7XHJcblx0fVxyXG5cclxuXHRwdWJsaWMgZ2V0IGxhc3RDb29yZEVuZHNBdEZpcnN0KCkge1xyXG5cdFx0cmV0dXJuIHRoaXMuX2xhc3RDb29yZEVuZHNBdEZpcnN0O1xyXG5cdH1cclxuXHJcblx0LyoqXHJcblx0ICogU2hvdWxkIGJlIGNhbGxlZCBvbmx5IGJlIHRoZSBjb3VwbGVkIFNWR0VsZW1lbnRDb250cm9sbGVyXHJcblx0ICogQHBhcmFtIGNvb3Jkc1xyXG5cdCAqL1xyXG5cdHB1YmxpYyBjYWxjdWxhdGUoY29vcmRzOiBDb29yZFtdKTogdm9pZCB7XHJcblx0XHR0aGlzLl9jb29yZHMgPSBjb29yZHM7XHJcblx0XHR0aGlzLl9zZWdtZW50TGVuZ3Rocy5sZW5ndGggPSAwO1xyXG5cdFx0Ly8gcmVzZXQgZGF0YVxyXG5cdFx0dGhpcy5fdG90YWxMZW5ndGggPSAwO1xyXG5cdFx0dGhpcy5fc2VnbWVudEFjY3VtdWxhdGVkTGVuZ3Rocy5sZW5ndGggPSAwO1xyXG5cclxuXHRcdC8vIHJlc2V0IHNpbXBsZmllZENvb3JkcztcclxuXHRcdHRoaXMuX3NpbXBsZmllZC5jb29yZHMgPSBjb29yZHMubGVuZ3RoID09PSAwID8gW10gOiBbY29vcmRzWzBdLngsIGNvb3Jkc1swXS55IV07XHJcblxyXG5cdFx0bGV0IHhTdW0gPSAwO1xyXG5cdFx0bGV0IHlTdW0gPSAwO1xyXG5cclxuXHRcdC8vIGlzIGNsb3NlZCBzaGFwZSB3aXRoIGxhc3QgY29vcmQgaXMgYWN0aWFsbHkgdGhlIGZpcnN0XHJcblx0XHR0aGlzLl9sYXN0Q29vcmRFbmRzQXRGaXJzdCA9XHJcblx0XHRcdGNvb3Jkcy5sZW5ndGggPiAxICYmXHJcblx0XHRcdGNvb3Jkc1swXS54ID09PSBjb29yZHNbY29vcmRzLmxlbmd0aCAtIDFdLnggJiZcclxuXHRcdFx0Y29vcmRzWzBdLnkgPT09IGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMV0ueTtcclxuXHJcblx0XHRsZXQgZGl2aWRlQnkgPSAwO1xyXG5cclxuXHRcdGZvciAobGV0IGNvb3JkSW5kZXggPSAwOyBjb29yZEluZGV4IDwgY29vcmRzLmxlbmd0aDsgY29vcmRJbmRleCsrKSB7XHJcblx0XHRcdGNvbnN0IGNvb3JkID0gY29vcmRzW2Nvb3JkSW5kZXhdO1xyXG5cclxuXHRcdFx0Y29uc3QgbGVuZ3RoQ2FsY3VsYXRvciA9IGNvb3JkTGVuZ3RoQ2FsY3VsYXRvcnNbY29vcmQudHlwZS50b1N0cmluZygpXTtcclxuXHJcblx0XHRcdGNvbnN0IGlzTGFzdENvb3JkSW5DbG9zZWRTaGFwZTogYm9vbGVhbiA9XHJcblx0XHRcdFx0dGhpcy5fbGFzdENvb3JkRW5kc0F0Rmlyc3QgJiYgY29vcmRJbmRleCA9PT0gY29vcmRzLmxlbmd0aCAtIDE7XHJcblxyXG5cdFx0XHRjb25zdCBwb2ludHMgPSBnZXRQb2ludHNPZkNvb3JkKGNvb3JkKTtcclxuXHRcdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpICs9IDIpIHtcclxuXHRcdFx0XHRpZiAoIWlzTGFzdENvb3JkSW5DbG9zZWRTaGFwZSB8fCBpIDwgcG9pbnRzLmxlbmd0aCAtIDIpIHtcclxuXHRcdFx0XHRcdCsrZGl2aWRlQnk7XHJcblx0XHRcdFx0XHQvLyBub3QgbGFzdCBjb29yZCdzIGxhc3QgMiBwb2ludHMgKHgsIHkpXHJcblx0XHRcdFx0XHR4U3VtICs9IHBvaW50c1tpXTtcclxuXHRcdFx0XHRcdGlmICh2YWx1ZUFzc2lnbmVkKHBvaW50c1tpICsgMV0pKSB7XHJcblx0XHRcdFx0XHRcdHlTdW0gKz0gcG9pbnRzW2kgKyAxXTtcclxuXHRcdFx0XHRcdH1cclxuXHRcdFx0XHR9XHJcblx0XHRcdH1cclxuXHJcblx0XHRcdC8vIGlmIHdlIGFyZSBpbiBmaXJzdCBjb29yZCwgaXQgaXMgYmVjYXVzZSBmaXJzdENvb3JkSXNNb3ZlVG8gaXMgdHJ1ZSBhbmQgcHJldiBjb29yZCBpcyAwLDBcclxuXHRcdFx0aWYgKGNvb3JkSW5kZXggPiAwKSB7XHJcblx0XHRcdFx0Y29uc3QgcHJldkNvb3JkOiBDb29yZCA9IGNvb3Jkc1tjb29yZEluZGV4IC0gMV07XHJcblx0XHRcdFx0Y29uc3QgcHJldmlvdXNTaW1wbGlmaWVkQ29vcmRzTGVuZ3RoID0gdGhpcy5fc2ltcGxmaWVkLmNvb3Jkcy5sZW5ndGg7XHJcblx0XHRcdFx0Y29uc3Qgc2VnbWVudExlbmd0aDogbnVtYmVyID0gbGVuZ3RoQ2FsY3VsYXRvcihcclxuXHRcdFx0XHRcdHByZXZDb29yZCxcclxuXHRcdFx0XHRcdGNvb3JkLFxyXG5cdFx0XHRcdFx0dGhpcy5fc2ltcGxmaWVkLmNvb3Jkc1xyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0dGhpcy5fc2VnbWVudFRvU2ltcGxpZmllZFJhbmdlLnB1c2goXHJcblx0XHRcdFx0XHR0aGlzLl9zaW1wbGZpZWQuY29vcmRzLmxlbmd0aCAtIHByZXZpb3VzU2ltcGxpZmllZENvb3Jkc0xlbmd0aFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0dGhpcy5fc2VnbWVudExlbmd0aHMucHVzaChzZWdtZW50TGVuZ3RoKTtcclxuXHRcdFx0XHR0aGlzLl9zZWdtZW50QWNjdW11bGF0ZWRMZW5ndGhzLnB1c2goXHJcblx0XHRcdFx0XHQodGhpcy5fc2VnbWVudEFjY3VtdWxhdGVkTGVuZ3Roc1t0aGlzLl9zZWdtZW50QWNjdW11bGF0ZWRMZW5ndGhzLmxlbmd0aCAtIDFdIHx8XHJcblx0XHRcdFx0XHRcdDApICsgc2VnbWVudExlbmd0aFxyXG5cdFx0XHRcdCk7XHJcblx0XHRcdFx0dGhpcy5fdG90YWxMZW5ndGggKz0gc2VnbWVudExlbmd0aDtcclxuXHRcdFx0fVxyXG5cdFx0fVxyXG5cclxuXHRcdC8vIGNhbGN1bGF0ZSBjZW50ZXIgcG9pbnRcclxuXHRcdHRoaXMuX2NlbnRlciA9IHtcclxuXHRcdFx0eDogeFN1bSAvIGRpdmlkZUJ5LFxyXG5cdFx0XHR5OiB5U3VtIC8gZGl2aWRlQnksXHJcblx0XHR9O1xyXG5cdH1cclxuXHJcblx0cHVibGljIGdldEJvcmRlckludGVyc2VjdGlvbihjb29yZHM6IENvb3JkW10sIHAxOiBQb2ludCwgc2hhcGVBbmNob3I/OiBQb2ludCk6IFBvaW50IHwgZmFsc2Uge1xyXG5cdFx0c2hhcGVBbmNob3IgPSBzaGFwZUFuY2hvciB8fCB0aGlzLl9jZW50ZXI7XHJcblxyXG5cdFx0cmV0dXJuIGZhbHNlO1xyXG5cdH1cclxufVxyXG4iLCJpbXBvcnQgU2VnbWVudHNEZXNjcmlwdG9yIGZyb20gJy4vZGVzY3JpcHRvcnMvU2VnbWVudHNEZXNjcmlwdG9yJztcclxuaW1wb3J0IFNWR0dlb21ldHJ5Q29udHJvbGxlciBmcm9tICcuLi9TVkdHZW9tZXRyeUNvbnRyb2xsZXInO1xyXG5cclxuZXhwb3J0IGVudW0gQ29vcmRUeXBlIHtcclxuXHRTY2FsYXIgPSAnU0NBTEFSJyxcclxuXHRMaW5lYXIgPSAnTElORUFSJyxcclxuXHRCZXppZXJNaXJyb3IgPSAnQkVaSUVSX01JUlJPUicsXHJcblx0QmV6aWVyQ3ViaWMgPSAnQkVaSUVSX0NVQklDJyxcclxuXHRCZXppZXJRdWFkcmF0aWMgPSAnQkVaSUVSX1FVQURSQVRJQycsXHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgUG9pbnQge1xyXG5cdHg6IG51bWJlcjtcclxuXHR5OiBudW1iZXI7XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgQ29vcmQge1xyXG5cdHR5cGU6IENvb3JkVHlwZTtcclxuXHR4OiBudW1iZXI7XHJcblx0eT86IG51bWJlcjtcclxuXHRtb3ZlPzogYm9vbGVhbjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBRdWFkcmF0aWNCZXppZXJDb29yZCBleHRlbmRzIENvb3JkIHtcclxuXHR5OiBudW1iZXI7XHJcblx0Y3RybFg6IG51bWJlcjtcclxuXHRjdHJsWTogbnVtYmVyO1xyXG5cdG1pcnJvclg/OiBudW1iZXI7XHJcblx0bWlycm9yWT86IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBDdWJpY0JlemllckNvb3JkIGV4dGVuZHMgUXVhZHJhdGljQmV6aWVyQ29vcmQge1xyXG5cdHk6IG51bWJlcjtcclxuXHRjdHJsWDI6IG51bWJlcjtcclxuXHRjdHJsWTI6IG51bWJlcjtcclxufVxyXG5cclxuLy8gZHJhd2luZyBjYXBhYmlsaXRpZXNcclxuZXhwb3J0IGludGVyZmFjZSBsaW5lVG9BYmxlIHtcclxuXHRsaW5lVG8oeDogbnVtYmVyLCB5OiBudW1iZXIpOiBsaW5lVG9BYmxlO1xyXG59XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIGhhc1NlZ21lbnRzRGVzY3JpcHRvciBleHRlbmRzIFNWR0dlb21ldHJ5Q29udHJvbGxlciB7XHJcblx0cmVhZG9ubHkgc2VnbWVudHNEZXNjcmlwdG9yOiBTZWdtZW50c0Rlc2NyaXB0b3I7XHJcblx0Z2V0Qm9yZGVySW50ZXJzZWN0aW9uOiAocDE6IFBvaW50LCBzaGFwZUFuY2hvcj86IFBvaW50IHwgdW5kZWZpbmVkKSA9PiBmYWxzZSB8IFBvaW50O1xyXG59XHJcblxyXG4vLyBkZWZvcm0gY2FwYWJpbGl0aWVzXHJcbmV4cG9ydCBpbnRlcmZhY2UgZGVmb3JtYWJsZVNWR0NvbnRyb2xsZXIge1xyXG5cdGFkZERlZm9ybWFibGVTZWdtZW50SW5kaWNlcyhpbmRpY2VzOiBudW1iZXIgfCBudW1iZXJbXSk6IGRlZm9ybWFibGVTVkdDb250cm9sbGVyO1xyXG5cdHJlbW92ZURlZm9ybWFibGVTZWdtZW50SW5kaWNlcyhpbmRpY2VzOiBudW1iZXIgfCBudW1iZXJbXSk6IGRlZm9ybWFibGVTVkdDb250cm9sbGVyO1xyXG5cdGNsZWFyRGVmb3JtYWJsZVNlZ21lbnRJbmRpY2VzKCk6IGRlZm9ybWFibGVTVkdDb250cm9sbGVyO1xyXG5cdHJlYWRvbmx5IGRlZm9ybWFibGVTZWdtZW50SW5kaWNlczogU2V0PG51bWJlcj47XHJcbn1cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgY2FuQmVJbnRlcnNlY3RlZEJ5TGluZSBleHRlbmRzIGRlZm9ybWFibGVTVkdDb250cm9sbGVyIHtcclxuXHQvLyBwMiB3aWxsIGJlIHRoZSBkZWZvcm1hYmxlIGdlb21ldHJ5IGNlbnRlclxyXG5cdGdldEludGVyc2VjdGlvblNlZ21lbnQobGluZVg6IG51bWJlciwgbGluZVk6IG51bWJlcik6IFBvaW50IHwgbnVsbDtcclxuXHQvLyBwMSBhbmQgcDIgcmVwcmVzZW50XHJcblx0Z2V0SW50ZXJzZWN0aW9uU2VnbWVudChcclxuXHRcdGxpbmVYMTogbnVtYmVyLFxyXG5cdFx0bGluZVkxOiBudW1iZXIsXHJcblx0XHRsaW5lWDI6IG51bWJlcixcclxuXHRcdGxpbmVZMjogbnVtYmVyXHJcblx0KTogUG9pbnQgfCBudWxsO1xyXG59XHJcbiIsImltcG9ydCB7IGNyZWF0ZVByb3h5IH0gZnJvbSAnc3JjL2hlbHBlcnMvb2JqZWN0X3V0aWxzJztcclxuaW1wb3J0IHsgZ2V0RGlzdGFuY2UgfSBmcm9tICdzcmMvaGVscGVycy9zaGFwZV91dGlscyc7XHJcbmltcG9ydCB7IENvb3JkLCBDdWJpY0JlemllckNvb3JkLCBQb2ludCwgQ29vcmRUeXBlLCBRdWFkcmF0aWNCZXppZXJDb29yZCB9IGZyb20gJy4uL2ludGVyZmFjZXMnO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiByZXR1cm4gdGhlIFggb3IgWSB2YWx1ZSBvZiBhbiBpbnRlcnBvbGF0ZWQgcG9pbnQgb24gYSBiZXppZXIgY3VydmVcclxuICogQHBhcmFtIHQgMCB0byAxIHZhbHVlIHJlcHJlc2VudGluZyB0aGUgcG9zaXRpb24gYmV0d2VlbiB0aGUgc3RhcnQgYW5kIHRoZSBlbmRcclxuICogQHBhcmFtIHN0YXJ0IHRoZSBYIG9yIFkgdmFsdWUgb2YgdGhlIHN0YXJ0IHBvaW50XHJcbiAqIEBwYXJhbSBzdGFydEN0cmwgdGhlIFggb3IgWSB2YWx1ZSBvZiB0aGUgc3RhcnQgcG9pbnRcclxuICogQHBhcmFtIGVuZEN0cmwgdGhlIFggb3IgWSB2YWx1ZSBvZiB0aGUgZW5kIHBvaW50XHJcbiAqIEBwYXJhbSBlbmQgdGhlIFggb3IgWSB2YWx1ZSBvZiB0aGUgZW5kIHBvaW50XHJcbiAqL1xyXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9pbnRYb3JZT25CZXppZXIoXHJcblx0dDogbnVtYmVyLFxyXG5cdHN0YXJ0OiBudW1iZXIsXHJcblx0c3RhcnRDdHJsOiBudW1iZXIsXHJcblx0ZW5kQ3RybDogbnVtYmVyLFxyXG5cdGVuZDogbnVtYmVyXHJcbik6IG51bWJlciB7XHJcblx0Y29uc3QgdDIgPSB0ICogdDtcclxuXHRjb25zdCB0MyA9IHQyICogdDtcclxuXHRyZXR1cm4gKFxyXG5cdFx0c3RhcnQgK1xyXG5cdFx0KC1zdGFydCAqIDMgKyB0ICogKDMgKiBzdGFydCAtIHN0YXJ0ICogdCkpICogdCArXHJcblx0XHQoMyAqIHN0YXJ0Q3RybCArIHQgKiAoLTYgKiBzdGFydEN0cmwgKyBzdGFydEN0cmwgKiAzICogdCkpICogdCArXHJcblx0XHQoZW5kQ3RybCAqIDMgLSBlbmRDdHJsICogMyAqIHQpICogdDIgK1xyXG5cdFx0ZW5kICogdDNcclxuXHQpO1xyXG59XHJcblxyXG5leHBvcnQgZnVuY3Rpb24gZ2V0QmV6aWVyQ3ViaWNTZWdtZW50cyhjMTogQ29vcmQsIGMyOiBDb29yZCwgc2VnbWVudHNDb3VudCA9IDUwKTogUG9pbnRbXSB7XHJcblx0Y29uc3Qgc2VjdGlvbkRlbHRhID0gMSAvIChzZWdtZW50c0NvdW50IC0gMSk7XHJcblx0Y29uc3QgY29vcmRzQWxvbmdDdXJ2ZTogUG9pbnRbXSA9IFtdO1xyXG5cdGZvciAobGV0IGkgPSAwOyBpIDwgc2VnbWVudHNDb3VudDsgaSsrKSB7XHJcblx0XHRjb29yZHNBbG9uZ0N1cnZlLnB1c2goe1xyXG5cdFx0XHR4OiBnZXRQb2ludFhvcllPbkJlemllcihcclxuXHRcdFx0XHRzZWN0aW9uRGVsdGEgKiBpLFxyXG5cdFx0XHRcdGMxLngsXHJcblx0XHRcdFx0KGMyIGFzIEN1YmljQmV6aWVyQ29vcmQpLmN0cmxYLFxyXG5cdFx0XHRcdChjMiBhcyBDdWJpY0JlemllckNvb3JkKS5jdHJsWDIsXHJcblx0XHRcdFx0YzIueFxyXG5cdFx0XHQpLFxyXG5cdFx0XHR5OiBnZXRQb2ludFhvcllPbkJlemllcihcclxuXHRcdFx0XHRzZWN0aW9uRGVsdGEgKiBpLFxyXG5cdFx0XHRcdGMxLnkgYXMgbnVtYmVyLFxyXG5cdFx0XHRcdChjMiBhcyBDdWJpY0JlemllckNvb3JkKS5jdHJsWSxcclxuXHRcdFx0XHQoYzIgYXMgQ3ViaWNCZXppZXJDb29yZCkuY3RybFkyLFxyXG5cdFx0XHRcdGMyLnkgYXMgbnVtYmVyXHJcblx0XHRcdCksXHJcblx0XHR9KTtcclxuXHR9XHJcblx0cmV0dXJuIGNvb3Jkc0Fsb25nQ3VydmU7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRCZXppZXJRdWFkcmF0aWNTZWdtZW50cyhcclxuXHRjMTogQ29vcmQsXHJcblx0YzI6IFF1YWRyYXRpY0JlemllckNvb3JkLFxyXG5cdHNlZ21lbnRzQ291bnQgPSA1MCxcclxuXHRweFRvbGVyYW5jZSA9IDJcclxuKTogUG9pbnRbXSB7XHJcblx0Y29uc3QgeyB4OiBBeCwgeTogQXkgfSA9IGMxO1xyXG5cdGNvbnN0IHsgY3RybFg6IEJ4LCBjdHJsWTogQnksIHg6IEN4LCB5OiBDeSB9ID0gYzI7XHJcblx0bGV0IGRlbHRhQkF4OiBudW1iZXIgPSBCeCAtIEF4O1xyXG5cdGxldCBkZWx0YUNCeDogbnVtYmVyID0gQ3ggLSBCeDtcclxuXHRsZXQgZGVsdGFCQXk6IG51bWJlciA9IEJ5IC0gQXkhO1xyXG5cdGxldCBkZWx0YUNCeTogbnVtYmVyID0gQ3kgLSBCeTtcclxuXHRsZXQgYXgsIGF5O1xyXG5cdGxldCBsYXN0WCA9IC0xMDAwMDtcclxuXHRsZXQgbGFzdFkgPSAtMTAwMDA7XHJcblx0bGV0IHB0czogUG9pbnRbXSA9IFt7IHg6IEF4LCB5OiBBeSEgfV07XHJcblx0Zm9yIChsZXQgaSA9IDE7IGkgPCBzZWdtZW50c0NvdW50IC0gMTsgaSsrKSB7XHJcblx0XHRsZXQgdCA9IGkgLyBzZWdtZW50c0NvdW50O1xyXG5cdFx0YXggPSBBeCArIGRlbHRhQkF4ICogdDtcclxuXHRcdGF5ID0gQXkhICsgZGVsdGFCQXkgKiB0O1xyXG5cdFx0bGV0IHggPSBheCArIChCeCArIGRlbHRhQ0J4ICogdCAtIGF4KSAqIHQ7XHJcblx0XHRsZXQgeSA9IGF5ICsgKEJ5ICsgZGVsdGFDQnkgKiB0IC0gYXkpICogdDtcclxuXHRcdGxldCBkeCA9IHggLSBsYXN0WDtcclxuXHRcdGxldCBkeSA9IHkgLSBsYXN0WTtcclxuXHRcdGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IHB4VG9sZXJhbmNlKSB7XHJcblx0XHRcdHB0cy5wdXNoKHsgeDogeCwgeTogeSB9KTtcclxuXHRcdFx0bGFzdFggPSB4O1xyXG5cdFx0XHRsYXN0WSA9IHk7XHJcblx0XHR9XHJcblx0fVxyXG5cdHB0cy5wdXNoKHsgeDogQ3gsIHk6IEN5IH0pO1xyXG5cdHJldHVybiBwdHM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXRRdWFkcmF0aWNCZXppZXJMZW5ndGgoY29vcmQxOiBDb29yZCwgY29vcmQyOiBRdWFkcmF0aWNCZXppZXJDb29yZCkge1xyXG5cdGNvbnN0IHsgeDogeDEsIHk6IHkxIH0gPSBjb29yZDE7XHJcblx0Y29uc3QgeyBjdHJsWDogeDIsIGN0cmxZOiB5MiwgeDogeDMsIHk6IHkzIH0gPSBjb29yZDI7XHJcblx0bGV0IGE6IG51bWJlcjtcclxuXHRsZXQgYjogbnVtYmVyO1xyXG5cdGxldCBjOiBudW1iZXI7XHJcblx0bGV0IHU6IG51bWJlcjtcclxuXHRjb25zdCB2MXggPSB4MiAqIDI7XHJcblx0Y29uc3QgdjF5ID0geTIgKiAyO1xyXG5cdGNvbnN0IGQgPSB4MSAtIHYxeCArIHgzO1xyXG5cdGNvbnN0IGQxID0geTEhIC0gdjF5ICsgeTM7XHJcblx0Y29uc3QgZSA9IHYxeCAtIDIgKiB4MTtcclxuXHRjb25zdCBlMSA9IHYxeSAtIDIgKiB5MSE7XHJcblx0bGV0IGMxID0gKGEgPSA0ICogKGQgKiBkICsgZDEgKiBkMSkpO1xyXG5cdGMxICs9IGIgPSA0ICogKGQgKiBlICsgZDEgKiBlMSk7XHJcblx0YzEgKz0gYyA9IGUgKiBlICsgZTEgKiBlMTtcclxuXHRjMSA9IDIgKiBNYXRoLnNxcnQoYzEpO1xyXG5cdGNvbnN0IGExID0gMiAqIGEgKiAodSA9IE1hdGguc3FydChhKSk7XHJcblx0Y29uc3QgdTEgPSBiIC8gdTtcclxuXHRhID0gNCAqIGMgKiBhIC0gYiAqIGI7XHJcblx0YyA9IDIgKiBNYXRoLnNxcnQoYyk7XHJcblx0cmV0dXJuIChhMSAqIGMxICsgdSAqIGIgKiAoYzEgLSBjKSArIGEgKiBNYXRoLmxvZygoMiAqIHUgKyB1MSArIGMxKSAvICh1MSArIGMpKSkgLyAoNCAqIGExKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldEJlemllckN1YmljTGVuZ3RoKFxyXG5cdGMxOiBDb29yZCxcclxuXHRjMjogQ29vcmQsXHJcblx0c2VnbWVudHNDb3VudCA9IDUwLFxyXG5cdGFycmF5Rm9yTmV3Q29vcmRzPzogbnVtYmVyW11cclxuKTogbnVtYmVyIHtcclxuXHRjb25zdCBwb2ludHNBbG9uZ0N1cnZlOiBQb2ludFtdID0gZ2V0QmV6aWVyQ3ViaWNTZWdtZW50cyhjMSwgYzIsIHNlZ21lbnRzQ291bnQpO1xyXG5cdGxldCBsZW5ndGhTdW0gPSAwO1xyXG5cclxuXHRmb3IgKGxldCBpID0gMTsgaSA8IHBvaW50c0Fsb25nQ3VydmUubGVuZ3RoOyBpKyspIHtcclxuXHRcdGlmIChhcnJheUZvck5ld0Nvb3Jkcykge1xyXG5cdFx0XHRhcnJheUZvck5ld0Nvb3Jkcy5wdXNoKHBvaW50c0Fsb25nQ3VydmVbaSAtIDFdLngpO1xyXG5cdFx0XHRhcnJheUZvck5ld0Nvb3Jkcy5wdXNoKHBvaW50c0Fsb25nQ3VydmVbaSAtIDFdLnkpO1xyXG5cdFx0XHRhcnJheUZvck5ld0Nvb3Jkcy5wdXNoKHBvaW50c0Fsb25nQ3VydmVbaV0ueCk7XHJcblx0XHRcdGFycmF5Rm9yTmV3Q29vcmRzLnB1c2gocG9pbnRzQWxvbmdDdXJ2ZVtpXS55KTtcclxuXHRcdH1cclxuXHRcdGxlbmd0aFN1bSArPSBnZXREaXN0YW5jZShcclxuXHRcdFx0cG9pbnRzQWxvbmdDdXJ2ZVtpIC0gMV0ueCxcclxuXHRcdFx0cG9pbnRzQWxvbmdDdXJ2ZVtpIC0gMV0ueSxcclxuXHRcdFx0cG9pbnRzQWxvbmdDdXJ2ZVtpXS54LFxyXG5cdFx0XHRwb2ludHNBbG9uZ0N1cnZlW2ldLnlcclxuXHRcdCk7XHJcblx0fVxyXG5cclxuXHRyZXR1cm4gbGVuZ3RoU3VtO1xyXG59XHJcbi8qXHJcbmZ1bmN0aW9uIGJlemllck1pcnJvcihjMTogQ29vcmQsIGMyOiBDb29yZCwgYzM/OkNvb3JkLCBzZWdtZW50c0NvdW50ID0gNTApOm51bWJlciB7XHJcblx0aWYgKGMzICYmIChjMy50eXBlID09PSBDb29yZFR5cGUuQmV6aWVyTWlycm9yIHx8IGMzLnR5cGUgPT09IENvb3JkVHlwZS5CZXppZXIpKSB7XHJcblx0XHQvLyBnb3QgcHJldmlvdXMgc2VnbWVudFxyXG5cdFx0Y29uc3Qge3R5cGUsIHgsIHkgPSAwfSA9IGMyO1xyXG5cdFx0aWYgKHR5cGUgPT09IENvb3JkVHlwZS5CZXppZXIpIHtcclxuXHRcdFx0Ly8gcHJldiBpcyBiZXppZXJcclxuXHRcdH0gZWxzZSB7XHJcblx0XHRcdC8vIHByZXYgaXMgYmV6aWVyIG1pcnJvclxyXG5cclxuXHRcdH1cclxuXHRcdGNvbnN0IHByZXZDdHJsWCA9IHggKyAoeCAtIChjMiBhcyBCZXppZXJDb29yZCkuY3RybFgyKTtcclxuXHRcdGNvbnN0IHByZXZDdHJsWSA9IHkgfHwgMCArICh5IHx8IDAgLSAoYzIgYXMgQmV6aWVyQ29vcmQpLmN0cmxZMik7XHJcblx0fVxyXG5cclxuXHQvLyBubyBwcmUtcHJldmlvdXMgY29vcmQgb3IgcHJlLXByZXZpb3VzIG5vdCBvZiBjb250aW51ZXMgdHlwZVxyXG5cdHJldHVybiBnZXRCZXppZXJDdWJpY0xlbmd0aChjMSwgYzIsIHNlZ21lbnRzQ291bnQpO1xyXG59XHJcbiovXHJcblxyXG5leHBvcnQgdHlwZSBQb2ludE9uQ29vcmRDYWxjdWxhdG9yID0gKFxyXG5cdGNvb3JkOiBDb29yZCxcclxuXHRwZXJjZW50YWdlT2ZTZWdtZW50OiBudW1iZXIsXHJcblx0cHJldmlvdXNDb29yZDogQ29vcmRcclxuKSA9PiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0gfCBuZXZlcjtcclxuXHJcbi8vIFRPRE86IG5lZWQgdW5pdCB0ZXN0c1xyXG4vKipcclxuICogbWFwIG9mIGZ1bmN0aW9ucyB1c2VkIHRvIGZpbmQgYSBwb2ludCBvbiBsaW5lIChDb29yZCkgYnkgcGVyY2VudGFnZSBmcm9tIHN0YXJ0IHRvIGVuZCBvZiB0aGUgbGluZSAoMCA9IHN0YXJ0LCAxID0gZW5kKVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IHBvaW50T25Db29yZENhbGN1bGF0b3JzID0gY3JlYXRlUHJveHk8UG9pbnRPbkNvb3JkQ2FsY3VsYXRvcj4oXHJcblx0e1xyXG5cdFx0TElORUFSOiAoY29vcmQ6IENvb3JkLCBwZXJjZW50YWdlT2ZTZWdtZW50OiBudW1iZXIsIHByZXZpb3VzQ29vcmQ6IENvb3JkKSA9PiAoe1xyXG5cdFx0XHR4OiAoY29vcmQueCAtIHByZXZpb3VzQ29vcmQueCkgKiBwZXJjZW50YWdlT2ZTZWdtZW50ICsgcHJldmlvdXNDb29yZC54LFxyXG5cdFx0XHR5OiAoY29vcmQueSEgLSBwcmV2aW91c0Nvb3JkLnkhKSAqIHBlcmNlbnRhZ2VPZlNlZ21lbnQgKyBwcmV2aW91c0Nvb3JkLnkhLFxyXG5cdFx0fSksXHJcblx0XHRCRVpJRVJfQ1VCSUM6IChjb29yZDogQ29vcmQsIHBlcmNlbnRhZ2VPZlNlZ21lbnQ6IG51bWJlciwgcHJldmlvdXNDb29yZDogQ29vcmQpID0+IHtcclxuXHRcdFx0Y29uc3Qgc3EgPSBjb29yZCBhcyBDdWJpY0JlemllckNvb3JkO1xyXG5cdFx0XHRyZXR1cm4ge1xyXG5cdFx0XHRcdHg6IGdldFBvaW50WG9yWU9uQmV6aWVyKFxyXG5cdFx0XHRcdFx0cGVyY2VudGFnZU9mU2VnbWVudCxcclxuXHRcdFx0XHRcdHByZXZpb3VzQ29vcmQueCxcclxuXHRcdFx0XHRcdHNxLmN0cmxYLFxyXG5cdFx0XHRcdFx0c3EuY3RybFgyLFxyXG5cdFx0XHRcdFx0c3EueFxyXG5cdFx0XHRcdCksXHJcblx0XHRcdFx0eTogZ2V0UG9pbnRYb3JZT25CZXppZXIoXHJcblx0XHRcdFx0XHRwZXJjZW50YWdlT2ZTZWdtZW50LFxyXG5cdFx0XHRcdFx0cHJldmlvdXNDb29yZC55ISxcclxuXHRcdFx0XHRcdHNxLmN0cmxZLFxyXG5cdFx0XHRcdFx0c3EuY3RybFkyLFxyXG5cdFx0XHRcdFx0c3EueSFcclxuXHRcdFx0XHQpLFxyXG5cdFx0XHR9O1xyXG5cdFx0fSxcclxuXHRcdC8vQkVaSUVSX01JUlJPUjogKGMxOiBDb29yZCwgYzI6IENvb3JkLCBjMzogQ29vcmQpID0+IC8vIFRPRE86IE5FRUQgSU1QTEVNRU5UQVRJT05cclxuXHRcdC8vUVVBRFJBVElDOiAoYzE6IENvb3JkLCBjMjogQ29vcmQsIGMzOiBDb29yZCkgPT4gLy8gVE9ETzogTkVFRCBJTVBMRU1FTlRBVElPTlxyXG5cdH0sXHJcblx0KGNvb3JkOiBDb29yZCkgPT4ge1xyXG5cdFx0dGhyb3cgYENvb3JkVHlwZSAke2Nvb3JkLnR5cGV9IGlzIG5vdCBpbXBsbWVudGVkIGluIHBvaW50T25Db29yZENhbGN1bGF0b3JzYDtcclxuXHR9XHJcbik7XHJcblxyXG5leHBvcnQgdHlwZSBDb29yZExlbmd0aENhbGN1bGF0b3IgPSAoXHJcblx0Y29vcmQ6IENvb3JkLFxyXG5cdHByZXZpb3VzQ29vcmQ6IENvb3JkLFxyXG5cdG5ld0Nvb3Jkcz86IG51bWJlcltdXHJcbikgPT4gbnVtYmVyIHwgbmV2ZXI7XHJcblxyXG5leHBvcnQgY29uc3QgY29vcmRMZW5ndGhDYWxjdWxhdG9ycyA9IGNyZWF0ZVByb3h5PENvb3JkTGVuZ3RoQ2FsY3VsYXRvcj4oXHJcblx0e1xyXG5cdFx0TElORUFSOiAoYzE6IENvb3JkLCBjMjogQ29vcmQsIG5ld0Nvb3Jkcz86IG51bWJlcltdKSA9PiB7XHJcblx0XHRcdGlmIChuZXdDb29yZHMpIHtcclxuXHRcdFx0XHRuZXdDb29yZHMucHVzaChjMi54KTtcclxuXHRcdFx0XHRuZXdDb29yZHMucHVzaChjMi55ISk7XHJcblx0XHRcdH1cclxuXHRcdFx0cmV0dXJuIGdldERpc3RhbmNlKGMxLngsIGMxLnkgfHwgMCwgYzIueCwgYzIueSB8fCAwKTtcclxuXHRcdH0sXHJcblx0XHRCRVpJRVJfQ1VCSUM6IChjMTogQ29vcmQsIGMyOiBDb29yZCwgbmV3Q29vcmRzPzogbnVtYmVyW10pID0+XHJcblx0XHRcdGdldEJlemllckN1YmljTGVuZ3RoKGMxLCBjMiwgNTAsIG5ld0Nvb3JkcyksXHJcblx0XHQvL0JFWklFUl9NSVJST1I6IChjMTogQ29vcmQsIGMyOiBDb29yZCwgYzM6IENvb3JkKSA9PiAvLyBUT0RPOiBORUVEIElNUExFTUVOVEFUSU9OXHJcblx0XHQvL1FVQURSQVRJQzogKGMxOiBDb29yZCwgYzI6IENvb3JkLCBjMzogQ29vcmQpID0+IC8vIFRPRE86IE5FRUQgSU1QTEVNRU5UQVRJT05cclxuXHR9LFxyXG5cdChwcmV2Q29vcmQ6IENvb3JkLCBjb29yZDogQ29vcmQpID0+IHtcclxuXHRcdHRocm93IGBDb29yZFR5cGUgJHtjb29yZC50eXBlfSBpcyBub3QgaW1wbG1lbnRlZCBpbiBjb29yZExlbmd0aENhbGN1bGF0b3JzYDtcclxuXHR9XHJcbik7XHJcblxyXG5jb25zdCBhcnIxOiBudW1iZXJbXSA9IG5ldyBBcnJheSgxKTtcclxuY29uc3QgYXJyMjogbnVtYmVyW10gPSBuZXcgQXJyYXkoMik7XHJcbmNvbnN0IGFycjQ6IG51bWJlcltdID0gbmV3IEFycmF5KDQpO1xyXG5jb25zdCBhcnI2OiBudW1iZXJbXSA9IG5ldyBBcnJheSg2KTtcclxudHlwZSBDb29yZFR5cGVkID0geyBba2V5IGluIENvb3JkVHlwZV06IChjb29yZDogQ29vcmQpID0+IG51bWJlcltdIH07XHJcblxyXG5jb25zdCBnZXRQb2ludHNDb29yZEhhbmRsZXJNYXA6IENvb3JkVHlwZWQgPSB7XHJcblx0W0Nvb3JkVHlwZS5TY2FsYXJdOiAoY29vcmQ6IENvb3JkKSA9PiB7XHJcblx0XHRhcnIxWzBdID0gY29vcmQueDtcclxuXHRcdHJldHVybiBhcnIxO1xyXG5cdH0sXHJcblx0W0Nvb3JkVHlwZS5MaW5lYXJdOiAoY29vcmQ6IENvb3JkKSA9PiB7XHJcblx0XHRhcnIyWzBdID0gY29vcmQueDtcclxuXHRcdGFycjJbMV0gPSBjb29yZC55ITtcclxuXHRcdHJldHVybiBhcnIyO1xyXG5cdH0sXHJcblx0W0Nvb3JkVHlwZS5CZXppZXJRdWFkcmF0aWNdOiAoY29vcmQ6IENvb3JkKSA9PiB7XHJcblx0XHRhcnI0WzBdID0gKGNvb3JkIGFzIFF1YWRyYXRpY0JlemllckNvb3JkKS54O1xyXG5cdFx0YXJyNFsxXSA9IChjb29yZCBhcyBRdWFkcmF0aWNCZXppZXJDb29yZCkueTtcclxuXHRcdGFycjRbMl0gPSAoY29vcmQgYXMgUXVhZHJhdGljQmV6aWVyQ29vcmQpLmN0cmxYO1xyXG5cdFx0YXJyNFszXSA9IChjb29yZCBhcyBRdWFkcmF0aWNCZXppZXJDb29yZCkuY3RybFk7XHJcblx0XHRyZXR1cm4gYXJyNDtcclxuXHR9LFxyXG5cdFtDb29yZFR5cGUuQmV6aWVyQ3ViaWNdOiAoY29vcmQ6IENvb3JkKSA9PiB7XHJcblx0XHRhcnI2WzBdID0gKGNvb3JkIGFzIEN1YmljQmV6aWVyQ29vcmQpLng7XHJcblx0XHRhcnI2WzFdID0gKGNvb3JkIGFzIEN1YmljQmV6aWVyQ29vcmQpLnk7XHJcblx0XHRhcnI2WzJdID0gKGNvb3JkIGFzIEN1YmljQmV6aWVyQ29vcmQpLmN0cmxYO1xyXG5cdFx0YXJyNlszXSA9IChjb29yZCBhcyBDdWJpY0JlemllckNvb3JkKS5jdHJsWTtcclxuXHRcdGFycjZbNF0gPSAoY29vcmQgYXMgQ3ViaWNCZXppZXJDb29yZCkuY3RybFgyO1xyXG5cdFx0YXJyNls1XSA9IChjb29yZCBhcyBDdWJpY0JlemllckNvb3JkKS5jdHJsWTI7XHJcblx0XHRyZXR1cm4gYXJyNjtcclxuXHR9LFxyXG5cdFtDb29yZFR5cGUuQmV6aWVyTWlycm9yXTogKCkgPT4ge1xyXG5cdFx0dGhyb3cgJ2JyZWFrIEJlemllck1pcnJvciB0byBjb29yZHMgbm90IGltcGxlbWVudGVkJztcclxuXHR9LFxyXG59O1xyXG5leHBvcnQgY29uc3QgZ2V0UG9pbnRzT2ZDb29yZCA9IChjb29yZDogQ29vcmQpOiBudW1iZXJbXSA9PlxyXG5cdGdldFBvaW50c0Nvb3JkSGFuZGxlck1hcFtjb29yZC50eXBlXShjb29yZCk7XHJcbiIsImltcG9ydCBMaW5lQ29udHJvbGxlciBmcm9tICcuL0xpbmVDb250cm9sbGVyJztcclxuaW1wb3J0IFBhdGhDb250cm9sbGVyIGZyb20gJy4vUGF0aENvbnRyb2xsZXInO1xyXG5pbXBvcnQgUG9seWdvbkNvbnRyb2xsZXIgZnJvbSAnLi9Qb2x5Z29uQ29udHJvbGxlcic7XHJcbmltcG9ydCBQb2x5bGluZUNvbnRyb2xsZXIgZnJvbSAnLi9Qb2x5bGluZUNvbnRyb2xsZXInO1xyXG5pbXBvcnQgQ2lyY2xlQ29udHJvbGxlciBmcm9tICcuL0NpcmNsZUNvbnRyb2xsZXInO1xyXG5pbXBvcnQgRWxsaXBzZUNvbnRyb2xsZXIgZnJvbSAnLi9FbGxpcHNlQ29udHJvbGxlcic7XHJcbmltcG9ydCBSZWN0Q29udHJvbGxlciBmcm9tICcuL1JlY3RDb250cm9sbGVyJztcclxuXHJcbmV4cG9ydCB7XHJcblx0TGluZUNvbnRyb2xsZXIsXHJcblx0UGF0aENvbnRyb2xsZXIsXHJcblx0UG9seWdvbkNvbnRyb2xsZXIsXHJcblx0UG9seWxpbmVDb250cm9sbGVyLFxyXG5cdENpcmNsZUNvbnRyb2xsZXIsXHJcblx0RWxsaXBzZUNvbnRyb2xsZXIsXHJcblx0UmVjdENvbnRyb2xsZXIsXHJcbn07XHJcbiIsImltcG9ydCB7IGNyZWF0ZVByb3h5IH0gZnJvbSAnLi9oZWxwZXJzL29iamVjdF91dGlscyc7XHJcbmltcG9ydCB7IGlkZW50aXR5Rm4gfSBmcm9tICcuL2hlbHBlcnMvZnVuY3Rpb25fdXRpbHMnO1xyXG5cclxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cclxuY29uc3QgZ2V0UGFyZW50RnVuY3Rpb25CeVR5cGUgPSBjcmVhdGVQcm94eTxGdW5jdGlvbj4oXHJcblx0e1xyXG5cdFx0c3RyaW5nOiAoc2VsZWN0b3I6IHN0cmluZykgPT4gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihzZWxlY3RvciksXHJcblx0fSxcclxuXHRpZGVudGl0eUZuXHJcbik7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTVkdFbGVtZW50KFxyXG5cdHR5cGU6ICdzdmcnLFxyXG5cdHN2Z1BhcmVudD86IG9wdGlvbmFsU1ZHT3JTdHJpbmcsXHJcblx0aWQ/OiBvcHRpb25hbFN0cmluZyxcclxuXHRjbGFzc05hbWVzPzogb3B0aW9uYWxTdHJpbmdcclxuKTogU1ZHRWxlbWVudDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNWR0VsZW1lbnQoXHJcblx0dHlwZTogJ2NpcmNsZScsXHJcblx0c3ZnUGFyZW50Pzogb3B0aW9uYWxTVkdPclN0cmluZyxcclxuXHRpZD86IG9wdGlvbmFsU3RyaW5nLFxyXG5cdGNsYXNzTmFtZXM/OiBvcHRpb25hbFN0cmluZ1xyXG4pOiBTVkdDaXJjbGVFbGVtZW50O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU1ZHRWxlbWVudChcclxuXHR0eXBlOiAnZWxsaXBzZScsXHJcblx0c3ZnUGFyZW50Pzogb3B0aW9uYWxTVkdPclN0cmluZyxcclxuXHRpZD86IG9wdGlvbmFsU3RyaW5nLFxyXG5cdGNsYXNzTmFtZXM/OiBvcHRpb25hbFN0cmluZ1xyXG4pOiBTVkdFbGxpcHNlRWxlbWVudDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNWR0VsZW1lbnQoXHJcblx0dHlwZTogJ2xpbmUnLFxyXG5cdHN2Z1BhcmVudD86IG9wdGlvbmFsU1ZHT3JTdHJpbmcsXHJcblx0aWQ/OiBvcHRpb25hbFN0cmluZyxcclxuXHRjbGFzc05hbWVzPzogb3B0aW9uYWxTdHJpbmdcclxuKTogU1ZHTGluZUVsZW1lbnQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTVkdFbGVtZW50KFxyXG5cdHR5cGU6ICdwYXRoJyxcclxuXHRzdmdQYXJlbnQ/OiBvcHRpb25hbFNWR09yU3RyaW5nLFxyXG5cdGlkPzogb3B0aW9uYWxTdHJpbmcsXHJcblx0Y2xhc3NOYW1lcz86IG9wdGlvbmFsU3RyaW5nXHJcbik6IFNWR1BhdGhFbGVtZW50O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gY3JlYXRlU1ZHRWxlbWVudChcclxuXHR0eXBlOiAncG9seWdvbicsXHJcblx0c3ZnUGFyZW50Pzogb3B0aW9uYWxTVkdPclN0cmluZyxcclxuXHRpZD86IG9wdGlvbmFsU3RyaW5nLFxyXG5cdGNsYXNzTmFtZXM/OiBvcHRpb25hbFN0cmluZ1xyXG4pOiBTVkdQb2x5Z29uRWxlbWVudDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNWR0VsZW1lbnQoXHJcblx0dHlwZTogJ3BvbHlsaW5lJyxcclxuXHRzdmdQYXJlbnQ/OiBvcHRpb25hbFNWR09yU3RyaW5nLFxyXG5cdGlkPzogb3B0aW9uYWxTdHJpbmcsXHJcblx0Y2xhc3NOYW1lcz86IG9wdGlvbmFsU3RyaW5nXHJcbik6IFNWR1BvbHlsaW5lRWxlbWVudDtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGNyZWF0ZVNWR0VsZW1lbnQoXHJcblx0dHlwZTogJ3JlY3QnLFxyXG5cdHN2Z1BhcmVudD86IG9wdGlvbmFsU1ZHT3JTdHJpbmcsXHJcblx0aWQ/OiBvcHRpb25hbFN0cmluZyxcclxuXHRjbGFzc05hbWVzPzogb3B0aW9uYWxTdHJpbmdcclxuKTogU1ZHUmVjdEVsZW1lbnQ7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBjcmVhdGVTVkdFbGVtZW50KFxyXG5cdHR5cGU6IFNWR0VsZW1lbnRUeXBlcyxcclxuXHRzdmdQYXJlbnQ/OiBvcHRpb25hbFNWR09yU3RyaW5nLFxyXG5cdGlkPzogb3B0aW9uYWxTdHJpbmcsXHJcblx0Y2xhc3NOYW1lcz86IG9wdGlvbmFsU3RyaW5nXHJcbik6IFNWR0VsZW1lbnQge1xyXG5cdGNvbnN0IGVsZW0gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdHlwZSk7XHJcblxyXG5cdGlkICYmIChlbGVtLmlkID0gaWQpO1xyXG5cdGNsYXNzTmFtZXMgJiYgZWxlbS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3NOYW1lcyk7XHJcblx0c3ZnUGFyZW50ICYmIGdldFBhcmVudEZ1bmN0aW9uQnlUeXBlW3R5cGVvZiBzdmdQYXJlbnRdKHN2Z1BhcmVudCkuYXBwZW5kQ2hpbGQoZWxlbSk7XHJcblxyXG5cdHJldHVybiBlbGVtO1xyXG59XHJcbiIsImNvbnN0IGlkZW50aXR5Rm46IEZ1bmN0aW9uID0gKHg6IGFueSkgPT4geDtcclxuY29uc3QgZW1wdHlGbjogRnVuY3Rpb24gPSAoKSA9PiB7fTtcclxuXHJcbmV4cG9ydCB7IGlkZW50aXR5Rm4sIGVtcHR5Rm4gfTtcclxuIiwiaW1wb3J0IHsgY3JlYXRlUHJveHkgfSBmcm9tICcuL29iamVjdF91dGlscyc7XHJcblxyXG5jb25zdCBhc3NpZ25lZFRlc3RzID0gY3JlYXRlUHJveHk8RnVuY3Rpb24+KFxyXG5cdHtcclxuXHRcdG9iamVjdDogKHZhbDogYW55KSA9PiB2YWwgIT09IG51bGwsXHJcblx0XHRudW1iZXI6ICh2YWw6IG51bWJlcikgPT4gIWlzTmFOKHZhbCksXHJcblx0XHR1bmRlZmluZWQ6ICgpID0+IGZhbHNlLFxyXG5cdH0sXHJcblx0KCkgPT4gdHJ1ZVxyXG4pO1xyXG5cclxuY29uc3QgaXNFbXB0eVRlc3RzID0gY3JlYXRlUHJveHk8RnVuY3Rpb24+KFxyXG5cdHtcclxuXHRcdHN0cmluZzogKHZhbDogc3RyaW5nKSA9PiB2YWwubGVuZ3RoID09PSAwLFxyXG5cdFx0bnVtYmVyOiAodmFsOiBudW1iZXIpID0+IGlzTmFOKHZhbCksXHJcblx0XHR1bmRlZmluZWQ6ICgpID0+IHRydWUsXHJcblx0XHRzeW1ib2w6ICgpID0+IGZhbHNlLFxyXG5cdFx0b2JqZWN0OiAodmFsOiBvYmplY3QpID0+IHtcclxuXHRcdFx0aWYgKHZhbCA9PT0gbnVsbCkge1xyXG5cdFx0XHRcdHJldHVybiB0cnVlO1xyXG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xyXG5cdFx0XHRcdHJldHVybiB2YWwubGVuZ3RoID09PSAwO1xyXG5cdFx0XHR9XHJcblx0XHRcdHJldHVybiBPYmplY3Qua2V5cyh2YWwpLmxlbmd0aCA9PT0gMDtcclxuXHRcdH0sXHJcblx0fSxcclxuXHQvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xyXG5cdCh2YWw6IGFueSkgPT4ge1xyXG5cdFx0dGhyb3cgYGNhbid0IGNoZWNrIGlmICR7dmFsfSBpcyBlbXB0eS4gdmFsaWRhdGlvbiB0ZXN0IGZvciB0eXBlICR7dHlwZW9mIHZhbH0gaXMgbm90IGRlZmluZWQgKD8hKWA7XHJcblx0fVxyXG4pO1xyXG5cclxuLyoqXHJcbiAqIEBkZXNjcmlwdGlvbiB0ZXN0IHRvIHNlZSB0aGUgdmFsdWUgKklTIE5PVCogbnVsbCAvIHVuZGVmaW5lZCAvIE5hTlxyXG4gKiBAcGFyYW0gdmFsXHJcbiAqIEByZXR1cm5zIGJvb2xlYW5cclxuICovXHJcbmNvbnN0IHZhbHVlQXNzaWduZWQgPSAodmFsOiBhbnkpID0+IGFzc2lnbmVkVGVzdHNbdHlwZW9mIHZhbF0odmFsKTtcclxuXHJcbi8qKlxyXG4gKiBAZGVzY2lwcmlvdG4gY2hlY2sgbm9uZSBvZiB0aGUgcHJvdmlkZWQgYXJndW1lbnRzIGlzIG51bGwgLyB1bmRlZmluZWQgLyBOYU4uIHVzZXMgdmFsdWVBc3NpZ25lZC4gZm9yIHZhbGlkYXRpbmcgbWVtYmVycyBvZiBhcnJheSwgdXNlIGFsbEFycmF5TWVtYmVyc0Fzc2lnbmVkXHJcbiAqIEBzZWUge0BsaW5rIHZhbHVlQXNzaWduZWR9XHJcbiAqIEBzZWUge0BsaW5rIGFsbEFycmF5TWVtYmVyc0Fzc2lnbmVkfVxyXG4gKiBAcGFyYW0gYXJnc1xyXG4gKiBAcmV0dXJucyBib29sZWFuXHJcbiAqL1xyXG5jb25zdCBhbGxWYWx1ZXNBc3NpZ25lZCA9ICguLi5hcmdzOiBhbnlbXSkgPT4gYXJncy5ldmVyeSh2YWx1ZUFzc2lnbmVkKTtcclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gY2hlY2sgYWxsIG1lbWJlcnMgb2YgdGhlIHByb3ZpZGVkIGFycmF5IGFyZSBhc3NpZ25lZC4gdXNlcyB2YWx1ZUFzc2lnbmVkLlxyXG4gKiBAcGFyYW0gYXJyYXlcclxuICogQHNlZSB7QGxpbmsgdmFsdWVBc3NpZ25lZH1cclxuICogQHJldHVybnMgYm9vbGVhblxyXG4gKi9cclxuY29uc3QgYWxsQXJyYXlNZW1iZXJzQXNzaWduZWQgPSAoYXJyYXk6IGFueVtdKSA9PiBhcnJheS5ldmVyeSh2YWx1ZUFzc2lnbmVkKTtcclxuXHJcbi8qKlxyXG4gKiBAZGVzY3JpcHRpb24gY2hlY2tzIGluIHRoZSB2YWx1ZSBpcyBlbXB0eSAoe30sIFtdLCBOYU4sIG51bGwsIHVuZGVmaW5lZClcclxuICogQHBhcmFtIHZhbFxyXG4gKiBAcmV0dXJucyBib29sZWFuXHJcbiAqL1xyXG5jb25zdCBpc0VtcHR5ID0gKHZhbDogYW55KSA9PiBpc0VtcHR5VGVzdHNbdHlwZW9mIHZhbF0odmFsKTtcclxuXHJcbmV4cG9ydCB7IHZhbHVlQXNzaWduZWQsIGFsbFZhbHVlc0Fzc2lnbmVkLCBhbGxBcnJheU1lbWJlcnNBc3NpZ25lZCwgaXNFbXB0eSB9O1xyXG4iLCJmdW5jdGlvbiBjcmVhdGVQcm94eTxUPih0YXJnZXQ6IG9iamVjdCwgZGVmPzogVCk6IHsgW2tleTogc3RyaW5nXTogVCB9IHtcclxuXHRjb25zdCBoYW5kbGVyID0ge1xyXG5cdFx0Z2V0OiAodGFyZ2V0OiBhbnksIHByb3A6IHN0cmluZyB8IG51bWJlciB8IHN5bWJvbCk6IFQgPT4ge1xyXG5cdFx0XHRyZXR1cm4gdGFyZ2V0W3Byb3BdIHx8IGRlZjtcclxuXHRcdH0sXHJcblx0fTtcclxuXHJcblx0cmV0dXJuIG5ldyBQcm94eSh0YXJnZXQsIGhhbmRsZXIpO1xyXG59XHJcblxyXG5leHBvcnQgY29uc3QgZW1wdHlPYmogPSBPYmplY3QuZnJlZXplKHt9KTtcclxuXHJcbmV4cG9ydCB7IGNyZWF0ZVByb3h5IH07XHJcbiIsIi8vICg0LzMpKk1hdGgudGFuKE1hdGguUEkgLyA4KVxyXG5leHBvcnQgY29uc3QgYmV6aWVyQ29udHJvbFBvaW50T2Zmc2V0Rm9yUXVhcnRlckNpcmNsZSA9IDAuNTUyMjg0NzQ5ODMwNzkzMztcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBnZXREaXN0YW5jZSh4MTogbnVtYmVyLCB5MTogbnVtYmVyLCB4MjogbnVtYmVyLCB5MjogbnVtYmVyKTogbnVtYmVyIHtcclxuXHRyZXR1cm4gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XHJcbn1cclxuXHJcbi8vIFRPRE86IGFkZCB1bml0IHRlc3RcclxuZXhwb3J0IGZ1bmN0aW9uIGdldERpc3RhbmNlQnlQb3dlcjIoeDE6IG51bWJlciwgeTE6IG51bWJlciwgeDI6IG51bWJlciwgeTI6IG51bWJlcik6IG51bWJlciB7XHJcblx0cmV0dXJuICh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKTtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldFNxdWFyZVBlcmltZXRlcih3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlcikge1xyXG5cdHJldHVybiAod2lkdGggKyBoZWlnaHQpICogMjtcclxufVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGdldENpcmNsZUNpcmN1bWZlcmVuY2UocmFkaXVzOiBudW1iZXIpIHtcclxuXHRyZXR1cm4gMiAqIE1hdGguUEkgKiByYWRpdXM7XHJcbn1cclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBsaW5lSW50ZXJzZWN0aW9uKFxyXG5cdHgxOiBudW1iZXIsXHJcblx0eTE6IG51bWJlcixcclxuXHR4MjogbnVtYmVyLFxyXG5cdHkyOiBudW1iZXIsXHJcblx0eDM6IG51bWJlcixcclxuXHR5MzogbnVtYmVyLFxyXG5cdHg0OiBudW1iZXIsXHJcblx0eTQ6IG51bWJlclxyXG4pIHtcclxuXHR2YXIgdWEsXHJcblx0XHR1YixcclxuXHRcdGRlbm9tID0gKHk0IC0geTMpICogKHgyIC0geDEpIC0gKHg0IC0geDMpICogKHkyIC0geTEpO1xyXG5cdGlmIChkZW5vbSA9PSAwKSB7XHJcblx0XHRyZXR1cm4gbnVsbDtcclxuXHR9XHJcblx0dWEgPSAoKHg0IC0geDMpICogKHkxIC0geTMpIC0gKHk0IC0geTMpICogKHgxIC0geDMpKSAvIGRlbm9tO1xyXG5cdHViID0gKCh4MiAtIHgxKSAqICh5MSAtIHkzKSAtICh5MiAtIHkxKSAqICh4MSAtIHgzKSkgLyBkZW5vbTtcclxuXHRyZXR1cm4ge1xyXG5cdFx0eDogeDEgKyB1YSAqICh4MiAtIHgxKSxcclxuXHRcdHk6IHkxICsgdWEgKiAoeTIgLSB5MSksXHJcblx0XHRzZWcxOiB1YSA+PSAwICYmIHVhIDw9IDEsXHJcblx0XHRzZWcyOiB1YiA+PSAwICYmIHViIDw9IDEsXHJcblx0fTtcclxufVxyXG4iLCJpbXBvcnQgY3JlYXRlU1ZHRWxlbWVudCBmcm9tICcuL2NyZWF0ZVNWR0VsZW1lbnQnO1xyXG5pbXBvcnQge1xyXG5cdExpbmVDb250cm9sbGVyLFxyXG5cdFBhdGhDb250cm9sbGVyLFxyXG5cdFBvbHlnb25Db250cm9sbGVyLFxyXG5cdFBvbHlsaW5lQ29udHJvbGxlcixcclxuXHRDaXJjbGVDb250cm9sbGVyLFxyXG5cdEVsbGlwc2VDb250cm9sbGVyLFxyXG5cdFJlY3RDb250cm9sbGVyLFxyXG59IGZyb20gJy4vY29udHJvbHMvaW5kZXgnO1xyXG5cclxuZXhwb3J0IHtcclxuXHRjcmVhdGVTVkdFbGVtZW50LFxyXG5cdExpbmVDb250cm9sbGVyLFxyXG5cdFBhdGhDb250cm9sbGVyLFxyXG5cdFBvbHlnb25Db250cm9sbGVyLFxyXG5cdFBvbHlsaW5lQ29udHJvbGxlcixcclxuXHRDaXJjbGVDb250cm9sbGVyLFxyXG5cdEVsbGlwc2VDb250cm9sbGVyLFxyXG5cdFJlY3RDb250cm9sbGVyLFxyXG59O1xyXG4iXSwic291cmNlUm9vdCI6IiJ9\n\n//# sourceURL=webpack:///./dist/bundle.js?");

/***/ }),

/***/ "./examples/src/path.js":
/*!******************************!*\
  !*** ./examples/src/path.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("const { createSVGElement, PathController, CircleController } = __webpack_require__(/*! ../../dist/bundle */ \"./dist/bundle.js\");\r\n\r\nconst svgRoot = document.getElementById('svg');\r\n\r\nconst pathElem = createSVGElement('path', svgRoot);\r\nconst path = new PathController(pathElem)\r\n\t.moveTo(50, 150)\r\n\t.lineTo(100, 150)\r\n\t.cubicTo(250, 0, 250, 350, 100, 200)\r\n\t.lineTo(50, 200)\r\n\t.lineTo(50, 150)\r\n\t.updateElement();\r\n\r\nconst center = path.calculate().segmentsDescriptor.center;\r\n\r\nconsole.log(center);\r\nconst circleElem = createSVGElement('circle', svgRoot);\r\nconst circleController = new CircleController(circleElem);\r\ncircleController.moveTo(133, 175).setRadius(5).updateElement();\r\n/*\r\nconst circleElem2 = createSVGElement('circle', svgRoot);\r\nconst circleController2 = new CircleController(circleElem2);\r\ncircleController2.moveTo(75, 175).setRadius(5).updateElement();\r\n*/\r\n// TODO: add a function that return all points of coords and coords' control points for visual\r\n\n\n//# sourceURL=webpack:///./examples/src/path.js?");

/***/ })

/******/ });